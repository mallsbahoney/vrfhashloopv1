// Generated by TaroBase SDK Generator: 2026-02-27T08:07:59.727Z
// Shared database client utilities and interfaces
// Edits may be overwritten by subsequent runs!

import { get, set, subscribe, setMany as tarobaseSetMany } from '@pooflabs/web';
import { getFiles, setFile } from '@pooflabs/web';
import { PublicKey } from '@solana/web3.js';
import { runQuery } from '@pooflabs/web';


// --- SDK Utilities ---

/**
 * Helper function to check if a value is a Time.Now value
 */
const isServerTimeNow = (value: any): value is TimeOperation => {
  return (
    value &&
    typeof value === "object" &&
    value.operation === "time" &&
    value.value === "now"
  );
};

/**
 * Helper function to check if a value is an Increment operation
 */
const isIncrementOperation = (value: any): value is IncrementOperation => {
  return (
    value &&
    typeof value === "object" &&
    value.operation === "increment" &&
    typeof value.value === "number"
  );
};

/**
 * Time utility for server-time values
 *
 * Use this when you want to store the current server time in a numeric field
 *
 * Example:
 * // For a schema with { createdAt: "Int" } or { createdAt: "UInt" }
 * await setPost("123", {
 *   title: "My Post",
 *   createdAt: Time.Now  // Will be stored as the server's current timestamp
 * });
 */
export interface TimeOperation {
  operation: string;
  value: string;
}

/**
 * Increment utility for incrementing/decrementing numeric fields
 *
 * Use this when you want to increment or decrement a numeric field by a specific amount
 *
 * Example:
 * // For a schema with { viewCount: "UInt" } or { balance: "Int" }
 * await updatePost("123", {
 *   viewCount: Increment.by(1)  // Increments viewCount by 1
 * });
 * await updateAccount("456", {
 *   balance: Increment.by(-50)  // Decrements balance by 50
 * });
 */
export interface IncrementOperation {
  operation: string;
  value: number;
}

export type TokenName = 'USDC' | 'SOL' | 'pSOL' | 'other';
export interface TokenAmount {
  type: 'token';
  name: TokenName;
  amount: number; // User-friendly amount (e.g., 10.5 SOL)
}

/**
 * AddressType represents a Solana public key for use in request data.
 */
export interface AddressType {
  type: 'address';
  publicKey: PublicKey | string;
}

/**
 * Helper function to check if a value is a TokenAmount value
 */
const isTokenAmount = (value: any): value is TokenAmount => {
  return value && typeof value === 'object' && value.type === 'token';
};

/**
 * Helper function to check if a value is an AddressType value
 */
const isAddressType = (value: any): value is AddressType => {
    // Check for the 'address' type property and that publicKey is an instance of PublicKey
    return value && typeof value === 'object' && value.type === 'address';
};


/**
 * Transforms special values (Time.now, Token.amount, Address.publicKey) in an object
 * to the format expected by the backend before sending the request.
 * This function is recursive and handles nested objects and arrays.
 */
const transformValues = (data: any): any => {
  // Handle null or non-object/array types directly
  if (!data || typeof data !== 'object') {
    return data;
  }

  // Check for specific object types first using type guards
  if (isServerTimeNow(data)) {
    // Pass Time.Now object as is; backend interprets it
    return { operation: 'time', value: 'now' };
  } else if (isIncrementOperation(data)) {
    // Pass Increment operation as is; backend interprets it
    return { operation: 'increment', value: data.value };
  } else if (isTokenAmount(data)) {
    // Convert user-friendly amount to backend's integer format based on decimals
    const { name, amount } = data; // Safe access due to type guard
    if (name === 'USDC') {
      return Math.round(amount * 10 ** 6); // 6 decimals for USDC
    } else if (name === 'SOL' || name === 'pSOL') {
      return Math.round(amount * 10 ** 9); // 9 decimals for SOL
    } else {
      // Assume a default of 6 decimals for custom tokens
      return Math.round(amount * 10 ** 6);
    }
  } else if (isAddressType(data)) {
     // Convert AddressType to its base58 string representation for the backend
     if (typeof data.publicKey === 'string') {
      return data.publicKey;
     } else {
      return data.publicKey.toBase58(); // Safe access due to type guard
     }
  }

  // Handle arrays: recursively transform each item
  if (Array.isArray(data)) {
    // Use map with explicit typing for clarity
    return data.map((item: any) => transformValues(item));
  }

  // Handle regular objects: recursively transform each property
  // Create a new object to avoid modifying the original
  const result: Record<string, any> = {};
  for (const key in data) {
    // Use safer check for own properties
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      result[key] = transformValues(data[key]);
    }
  }
  return result;
};

// --- SDK Helper Objects ---

export const Token: {
  /**
   * Creates a TokenAmount object representing a specific amount of a token.
   * @param name The name of the token (e.g., 'USDC', 'SOL', 'pSOL').
   * @param amount The user-friendly amount (e.g., 10.5 for 10.5 USDC).
   */
  amount: (name: TokenName, amount: number) => TokenAmount;
  /**
   * Converts a TokenAmount object back to its integer representation based on decimals.
   * Useful if you need the raw integer value on the client side.
   */
  convert: (amount: TokenAmount) => number;
} = {
  amount: (name: TokenName, amount: number): TokenAmount => ({
    type: 'token',
    name,
    amount,
  }),
  convert: (amount: TokenAmount): number => {
    // This logic mirrors the transformation in transformValues
    if (amount.name === 'USDC') {
      return Math.round(amount.amount * 10 ** 6);
    } else if (amount.name === 'SOL' || amount.name === 'pSOL') {
      return Math.round(amount.amount * 10 ** 9);
    }
    return Math.round(amount.amount * 10 ** 6); // Default or handle 'other'
  },
};

export const Time: {
  /**
   * Represents the server's current time. Use this value for 'Int' or 'UInt' fields
   * in request data where you want the server to insert the timestamp.
   */
  Now: TimeOperation;
} = {
  Now: { operation: "time", value: "now" }
};

export const Increment: {
  /**
   * Creates an increment/decrement operation for numeric fields.
   * Use positive values to increment, negative values to decrement.
   * @param value The amount to increment (positive) or decrement (negative)
   *
   * Example:
   * // Increment a counter by 1
   * await updatePost("123", { viewCount: Increment.by(1) });
   *
   * // Decrement a balance by 50
   * await updateAccount("456", { balance: Increment.by(-50) });
   */
  by: (value: number) => IncrementOperation;
} = {
  by: (value: number): IncrementOperation => ({
    operation: "increment",
    value
  })
};

export const Address: {
  /**
   * Creates an AddressType object from a PublicKey instance or a base58 string.
   * Validates the input and throws an error if invalid.
   * Special case: 'solana' is allowed as a reserved string representing native SOL.
   * @param key A PublicKey instance, a base58 encoded public key string, or 'solana' for native SOL.
   */
  publicKey: (key: PublicKey | string) => AddressType;
} = {
  publicKey: (key: PublicKey | string): AddressType => {
    if (typeof key === 'string') {
      // Special case: 'solana' represents native SOL asset
      if (key === 'solana') {
        return {
          type: 'address',
          publicKey: 'solana',
        };
      }
      // Validate format: Solana addresses are 32-44 base58 characters
      if (key.length < 32 || key.length > 44) {
        throw new Error(`Invalid Solana address length: ${key.length}. Must be 32-44 characters.`);
      }
      const base58Regex = /^[1-9A-HJ-NP-Za-km-z]+$/;
      if (!base58Regex.test(key)) {
        throw new Error(`Invalid Solana address: contains invalid characters. Must be base58 encoded.`);
      }
      try {
        // Validate and create PublicKey from string
        const pkInstance = new PublicKey(key);
        return {
          type: 'address',
          publicKey: pkInstance,
        };
      } catch (e) {
        // Safer error handling
        const message = e instanceof Error ? e.message : String(e);
        console.error(`Invalid public key string provided: ${key}`, message);
        throw new Error(`Invalid public key string: ${key}. ${message}`);
      }
    } else if (key instanceof PublicKey) {
      return {
        type: 'address',
        publicKey: key,
      };
    } else {
      // Handle invalid input type
      throw new Error('Invalid input for Address.publicKey: Must be a PublicKey instance or a base58 string.');
    }
  },
};

// Re-export SDK functions for collection files
export { get, set, subscribe, getFiles, setFile, runQuery, transformValues, PublicKey };

// --- Common Interfaces ---
/**
 * Common metadata fields added by TaroBase to document responses.
 */
export interface TarobaseMetadata {
  id: string;
  tarobase_created_at: number;
}

/**
 * Represents a file stored in TaroBase Storage.
 */
export interface FileItem {
  path: string;
  url: string;
}

/**
 * Represents a document operation for use with setMany.
 */
export interface DocumentOperation {
  path: string;
  document: any;
}

// --- Batch Operations ---

/**
 * Execute multiple document operations in a single atomic batch.
 * Use build* functions from collection files to create operations.
 * 
 * @example
 * // Atomic update across collections
 * await setMany([
 *   buildUser(userId, { name: 'John' }),
 *   buildPost(postId, { author: userId }),
 * ]);
 */
export async function setMany(operations: DocumentOperation[]): Promise<any> {
  return await tarobaseSetMany(operations);
}

// --- Error Formatting ---

/**
 * Safely format an error for logging (avoids [object Object] in logs)
 * Handles circular references, empty messages, and non-Error objects
 * Always includes the full error object for comprehensive debugging
 */
export function formatError(error: unknown): string {
  if (error === null) return 'null';
  if (error === undefined) return 'undefined';
  if (typeof error === 'string') return error || 'Empty error string';

  // For Error instances, prepend the message for readability
  const prefix = error instanceof Error ? `${error.message?.trim() || 'No message'} | Full error: ` : '';

  try {
    // Use Object.getOwnPropertyNames to include non-enumerable properties (like Error's name, message, stack)
    const str = JSON.stringify(error, Object.getOwnPropertyNames(error), 2);
    return prefix + (str || 'Empty object');
  } catch {
    // Circular reference or other stringify error
    return prefix + 'Unserializable error';
  }
}
