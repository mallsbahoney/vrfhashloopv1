// Generated by TaroBase SDK Generator: 2026-02-27T08:07:59.727Z
// Edits may be overwritten by subsequent runs!

import { get, set, subscribe, setMany as tarobaseSetMany } from '@pooflabs/web';
import { getFiles, setFile } from '@pooflabs/web';
import { PublicKey } from '@solana/web3.js';
import { runQuery } from '@pooflabs/web'; 


// --- SDK Utilities ---

/**
 * Helper function to check if a value is a Time.Now value
 */
const isServerTimeNow = (value: any): value is TimeOperation => {
  return (
    value &&
    typeof value === "object" &&
    value.operation === "time" &&
    value.value === "now"
  );
};

/**
 * Helper function to check if a value is an Increment operation
 */
const isIncrementOperation = (value: any): value is IncrementOperation => {
  return (
    value &&
    typeof value === "object" &&
    value.operation === "increment" &&
    typeof value.value === "number"
  );
};

/**
 * Time utility for server-time values
 *
 * Use this when you want to store the current server time in a numeric field
 *
 * Example:
 * // For a schema with { createdAt: "Int" } or { createdAt: "UInt" }
 * await setPost("123", {
 *   title: "My Post",
 *   createdAt: Time.Now  // Will be stored as the server's current timestamp
 * });
 */
export interface TimeOperation {
  operation: string;
  value: string;
}

/**
 * Increment utility for incrementing/decrementing numeric fields
 *
 * Use this when you want to increment or decrement a numeric field by a specific amount
 *
 * Example:
 * // For a schema with { viewCount: "UInt" } or { balance: "Int" }
 * await updatePost("123", {
 *   viewCount: Increment.by(1)  // Increments viewCount by 1
 * });
 * await updateAccount("456", {
 *   balance: Increment.by(-50)  // Decrements balance by 50
 * });
 */
export interface IncrementOperation {
  operation: string;
  value: number;
}

export type TokenName = 'USDC' | 'SOL' | 'pSOL' | 'other';
export interface TokenAmount {
  type: 'token';
  name: TokenName;
  amount: number; // User-friendly amount (e.g., 10.5 SOL)
}

/**
 * AddressType represents a Solana public key for use in request data.
 */
export interface AddressType {
  type: 'address';
  publicKey: PublicKey | string;
}

/**
 * Helper function to check if a value is a TokenAmount value
 */
const isTokenAmount = (value: any): value is TokenAmount => {
  return value && typeof value === 'object' && value.type === 'token';
};

/**
 * Helper function to check if a value is an AddressType value
 */
const isAddressType = (value: any): value is AddressType => {
    // Check for the 'address' type property and that publicKey is an instance of PublicKey
    return value && typeof value === 'object' && value.type === 'address';
};


/**
 * Transforms special values (Time.now, Token.amount, Address.publicKey) in an object
 * to the format expected by the backend before sending the request.
 * This function is recursive and handles nested objects and arrays.
 */
const transformValues = (data: any): any => {
  // Handle null or non-object/array types directly
  if (!data || typeof data !== 'object') {
    return data;
  }

  // Check for specific object types first using type guards
  if (isServerTimeNow(data)) {
    // Pass Time.Now object as is; backend interprets it
    return { operation: 'time', value: 'now' };
  } else if (isIncrementOperation(data)) {
    // Pass Increment operation as is; backend interprets it
    return { operation: 'increment', value: data.value };
  } else if (isTokenAmount(data)) {
    // Convert user-friendly amount to backend's integer format based on decimals
    const { name, amount } = data; // Safe access due to type guard
    if (name === 'USDC') {
      return Math.round(amount * 10 ** 6); // 6 decimals for USDC
    } else if (name === 'SOL' || name === 'pSOL') {
      return Math.round(amount * 10 ** 9); // 9 decimals for SOL
    } else {
      // Assume a default of 6 decimals for custom tokens
      return Math.round(amount * 10 ** 6);
    }
  } else if (isAddressType(data)) {
     // Convert AddressType to its base58 string representation for the backend
     if (typeof data.publicKey === 'string') {
      return data.publicKey;
     } else {
      return data.publicKey.toBase58(); // Safe access due to type guard
     }
  }

  // Handle arrays: recursively transform each item
  if (Array.isArray(data)) {
    // Use map with explicit typing for clarity
    return data.map((item: any) => transformValues(item));
  }

  // Handle regular objects: recursively transform each property
  // Create a new object to avoid modifying the original
  const result: Record<string, any> = {};
  for (const key in data) {
    // Use safer check for own properties
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      result[key] = transformValues(data[key]);
    }
  }
  return result;
};

// --- SDK Helper Objects ---

export const Token: {
  /**
   * Creates a TokenAmount object representing a specific amount of a token.
   * @param name The name of the token (e.g., 'USDC', 'SOL', 'pSOL').
   * @param amount The user-friendly amount (e.g., 10.5 for 10.5 USDC).
   */
  amount: (name: TokenName, amount: number) => TokenAmount;
  /**
   * Converts a TokenAmount object back to its integer representation based on decimals.
   * Useful if you need the raw integer value on the client side.
   */
  convert: (amount: TokenAmount) => number;
} = {
  amount: (name: TokenName, amount: number): TokenAmount => ({
    type: 'token',
    name,
    amount,
  }),
  convert: (amount: TokenAmount): number => {
    // This logic mirrors the transformation in transformValues
    if (amount.name === 'USDC') {
      return Math.round(amount.amount * 10 ** 6);
    } else if (amount.name === 'SOL' || amount.name === 'pSOL') {
      return Math.round(amount.amount * 10 ** 9);
    }
    return Math.round(amount.amount * 10 ** 6); // Default or handle 'other'
  },
};

export const Time: {
  /**
   * Represents the server's current time. Use this value for 'Int' or 'UInt' fields
   * in request data where you want the server to insert the timestamp.
   */
  Now: TimeOperation;
} = {
  Now: { operation: "time", value: "now" }
};

export const Increment: {
  /**
   * Creates an increment/decrement operation for numeric fields.
   * Use positive values to increment, negative values to decrement.
   * @param value The amount to increment (positive) or decrement (negative)
   *
   * Example:
   * // Increment a counter by 1
   * await updatePost("123", { viewCount: Increment.by(1) });
   *
   * // Decrement a balance by 50
   * await updateAccount("456", { balance: Increment.by(-50) });
   */
  by: (value: number) => IncrementOperation;
} = {
  by: (value: number): IncrementOperation => ({
    operation: "increment",
    value
  })
};

export const Address: {
  /**
   * Creates an AddressType object from a PublicKey instance or a base58 string.
   * Validates the input and throws an error if invalid.
   * Special case: 'solana' is allowed as a reserved string representing native SOL.
   * @param key A PublicKey instance, a base58 encoded public key string, or 'solana' for native SOL.
   */
  publicKey: (key: PublicKey | string) => AddressType;
} = {
  publicKey: (key: PublicKey | string): AddressType => {
    if (typeof key === 'string') {
      // Special case: 'solana' represents native SOL asset
      if (key === 'solana') {
        return {
          type: 'address',
          publicKey: 'solana',
        };
      }
      // Validate format: Solana addresses are 32-44 base58 characters
      if (key.length < 32 || key.length > 44) {
        throw new Error(`Invalid Solana address length: ${key.length}. Must be 32-44 characters.`);
      }
      const base58Regex = /^[1-9A-HJ-NP-Za-km-z]+$/;
      if (!base58Regex.test(key)) {
        throw new Error(`Invalid Solana address: contains invalid characters. Must be base58 encoded.`);
      }
      try {
        // Validate and create PublicKey from string
        const pkInstance = new PublicKey(key);
        return {
          type: 'address',
          publicKey: pkInstance,
        };
      } catch (e) {
        // Safer error handling
        const message = e instanceof Error ? e.message : String(e);
        console.error(`Invalid public key string provided: ${key}`, message);
        throw new Error(`Invalid public key string: ${key}. ${message}`);
      }
    } else if (key instanceof PublicKey) {
      return {
        type: 'address',
        publicKey: key,
      };
    } else {
      // Handle invalid input type
      throw new Error('Invalid input for Address.publicKey: Must be a PublicKey instance or a base58 string.');
    }
  },
};

// --- Common Interfaces ---
/**
 * Common metadata fields added by TaroBase to document responses.
 */
export interface TarobaseMetadata {
  id: string;
  tarobase_created_at: number; // epoch milliseconds
}

/**
 * Represents a file stored in TaroBase Storage.
 */
export interface FileItem {
  path: string; // Full path within storage
  url: string;  // Publicly accessible URL
}

/**
 * Represents a document operation for use with setMany.
 * Used by build functions to create properly typed operations.
 */
export interface DocumentOperation {
  path: string;
  document: any;
}

// --- Batch Operations ---

/**
 * Execute multiple document operations in a single batch.
 * @param operations Array of DocumentOperation objects created by build functions
 * @returns Promise resolving to the result of the batch operation
 */
export async function setMany(operations: DocumentOperation[]): Promise<any> {
  return await tarobaseSetMany(operations);
}

// --- Error Formatting ---

/**
 * Safely format an error for logging (avoids [object Object] in logs)
 * Handles circular references, empty messages, and non-Error objects
 * Always includes the full error object for comprehensive debugging
 */
export function formatError(error: unknown): string {
  if (error === null) return 'null';
  if (error === undefined) return 'undefined';
  if (typeof error === 'string') return error || 'Empty error string';

  // For Error instances, prepend the message for readability
  const prefix = error instanceof Error ? `${error.message?.trim() || 'No message'} | Full error: ` : '';

  try {
    // Use Object.getOwnPropertyNames to include non-enumerable properties (like Error's name, message, stack)
    const str = JSON.stringify(error, Object.getOwnPropertyNames(error), 2);
    return prefix + (str || 'Empty object');
  } catch {
    // Circular reference or other stringify error
    return prefix + 'Unserializable error';
  }
}

// --- Generated Functions by Policy Path ---

// --- Path: adminFiles/$fileId ---

/**
 * Handles AdminFiles files (Get Single File based on its ID, null if not found)
 */
export async function getAdminFiles(fileId: string): Promise<FileItem | null> {
  try {
    const rawResult = await getFiles(`adminFiles/${fileId}`);
    if (!rawResult || !Array.isArray(rawResult) || rawResult.length === 0) return null;
    return rawResult[0] as FileItem;
  } catch (error) {
    console.error(`Error getting file AdminFiles: ${formatError(error)}`);
    return null;
  }
}

/**
 * Handles AdminFiles files (Upload/Replace a File and persist it keyed by its ID) To get the file URL use the getAdminFiles function right after this one.
 * @returns A boolean indicating whether the upload succeeded (true) or failed (false). Always check this value to confirm the upload worked.
 */
export async function uploadAdminFiles(fileId: string, file: File): Promise<boolean> {
  try {
    const pathUsed = `adminFiles/${fileId}`;
    const result = await setFile(pathUsed, file);
    return !!result;
  } catch (error) {
    console.error(`Error uploading file AdminFiles: ${formatError(error)}`);
    return false;
  }
}

/**
 * Handles AdminFiles files (Delete File based on its ID)
 * @returns A boolean indicating whether the delete succeeded (true) or failed (false). Always check this value to confirm the delete worked.
 */
export async function deleteAdminFiles(fileId: string): Promise<boolean> {
  try {
    await setFile(`adminFiles/${fileId}`, null);
    return true;
  } catch (error) {
    console.error(`Error deleting file AdminFiles: ${formatError(error)}`);
    return false;
  }
}

// --- Path: appFiles/$fileId ---

/**
 * Handles AppFiles files (Get Single File based on its ID, null if not found)
 */
export async function getAppFiles(fileId: string): Promise<FileItem | null> {
  try {
    const rawResult = await getFiles(`appFiles/${fileId}`);
    if (!rawResult || !Array.isArray(rawResult) || rawResult.length === 0) return null;
    return rawResult[0] as FileItem;
  } catch (error) {
    console.error(`Error getting file AppFiles: ${formatError(error)}`);
    return null;
  }
}

/**
 * Handles AppFiles files (Upload/Replace a File and persist it keyed by its ID) To get the file URL use the getAppFiles function right after this one.
 * @returns A boolean indicating whether the upload succeeded (true) or failed (false). Always check this value to confirm the upload worked.
 */
export async function uploadAppFiles(fileId: string, file: File): Promise<boolean> {
  try {
    const pathUsed = `appFiles/${fileId}`;
    const result = await setFile(pathUsed, file);
    return !!result;
  } catch (error) {
    console.error(`Error uploading file AppFiles: ${formatError(error)}`);
    return false;
  }
}

/**
 * Handles AppFiles files (Delete File based on its ID)
 * @returns A boolean indicating whether the delete succeeded (true) or failed (false). Always check this value to confirm the delete worked.
 */
export async function deleteAppFiles(fileId: string): Promise<boolean> {
  try {
    await setFile(`appFiles/${fileId}`, null);
    return true;
  } catch (error) {
    console.error(`Error deleting file AppFiles: ${formatError(error)}`);
    return false;
  }
}

// --- Path: commonQueries/$queryId ---

export interface CommonQueriesRequest {

}

export interface CommonQueriesResponse {

  id: string;
  tarobase_created_at: number;
}

/**
 * 
  Read Operation Details: Anyone can use these queries: (1) Balance queries - check SOL, USDC, or any SPL token balance for any wallet address. (2) Jupiter swap quotes - get expected output amounts for token swaps via Jupiter aggregator. (3) Meteora swap quotes - get expected output amounts for Meteora dynamic bonding curve pools.
   (Get Single Item)
 */
export async function getCommonQueries(queryId: string): Promise<CommonQueriesResponse | null> {
  try {
    const result = await get(`commonQueries/${queryId}`);
    return result as CommonQueriesResponse | null;
  } catch (error) {
    console.error(`Error getting CommonQueries: ${formatError(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single CommonQueries document. (
  Read Operation Details: Anyone can use these queries: (1) Balance queries - check SOL, USDC, or any SPL token balance for any wallet address. (2) Jupiter swap quotes - get expected output amounts for token swaps via Jupiter aggregator. (3) Meteora swap quotes - get expected output amounts for Meteora dynamic bonding curve pools.
  )
 */
export function subscribeCommonQueries(callback: (data: CommonQueriesResponse | null) => void, queryId: string): Promise<() => Promise<void>> {
  return subscribe(`commonQueries/${queryId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as CommonQueriesResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to CommonQueries at path '${`commonQueries/${queryId}`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get many CommonQueries items from collection commonQueries
 
  Read Operation Details: Anyone can use these queries: (1) Balance queries - check SOL, USDC, or any SPL token balance for any wallet address. (2) Jupiter swap quotes - get expected output amounts for token swaps via Jupiter aggregator. (3) Meteora swap quotes - get expected output amounts for Meteora dynamic bonding curve pools.
  
 */
export async function getManyCommonQueries(filter: string = ""): Promise<CommonQueriesResponse[]> {
  try {
    const results = await get("commonQueries", { prompt: filter });
    return Array.isArray(results) ? results as CommonQueriesResponse[] : [];
  } catch (error) {
    console.error(`Error getting CommonQueries collection at path 'commonQueries': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in CommonQueries collection at commonQueries
 
  Read Operation Details: Anyone can use these queries: (1) Balance queries - check SOL, USDC, or any SPL token balance for any wallet address. (2) Jupiter swap quotes - get expected output amounts for token swaps via Jupiter aggregator. (3) Meteora swap quotes - get expected output amounts for Meteora dynamic bonding curve pools.
  
 */
export function subscribeManyCommonQueries(callback: (data: CommonQueriesResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("commonQueries", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as CommonQueriesResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to CommonQueries collection at path '${"commonQueries"}': ${formatError(error)}`);
    }
  });
}

/**
 * Get all CommonQueries items from collection commonQueries
 
  Read Operation Details: Anyone can use these queries: (1) Balance queries - check SOL, USDC, or any SPL token balance for any wallet address. (2) Jupiter swap quotes - get expected output amounts for token swaps via Jupiter aggregator. (3) Meteora swap quotes - get expected output amounts for Meteora dynamic bonding curve pools.
  
 */
export async function getAllCommonQueries(filter: string = ""): Promise<CommonQueriesResponse[]> {
  try {
    const results = await get("commonQueries", { prompt: filter });
    return Array.isArray(results) ? results as CommonQueriesResponse[] : [];
  } catch (error) {
    console.error(`Error getting CommonQueries collection at path 'commonQueries': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in CommonQueries collection at commonQueries
 
  Read Operation Details: Anyone can use these queries: (1) Balance queries - check SOL, USDC, or any SPL token balance for any wallet address. (2) Jupiter swap quotes - get expected output amounts for token swaps via Jupiter aggregator. (3) Meteora swap quotes - get expected output amounts for Meteora dynamic bonding curve pools.
  
 */
export function subscribeAllCommonQueries(callback: (data: CommonQueriesResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("commonQueries", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as CommonQueriesResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to CommonQueries collection at path '${"commonQueries"}': ${formatError(error)}`);
    }
  });
}

/** Arguments accepted by the "solBalance" query on CommonQueries. */
interface CommonQueriesSolBalanceArgs {
  walletAddress: string;
}

/**
 * Runs the "solBalance" query on CommonQueries.
 * Description: Get SOL balance for a wallet address in lamports (1 SOL = 1,000,000,000 lamports). Pass walletAddress as parameter.
 * Query Logic: @TokenPlugin.getBalance(@newData.walletAddress, @constants.SOL)
 */
export async function runSolBalanceQueryForCommonQueries(queryId: string, args: CommonQueriesSolBalanceArgs): Promise<number> {
  try {
    const result = await runQuery(`commonQueries/${queryId}`, "solBalance", args);
    return result as number;
  } catch (error) {
    console.error(`Error running query "solBalance" on CommonQueries: ${formatError(error)}`);
    throw error;
  }
}

/** Arguments accepted by the "usdcBalance" query on CommonQueries. */
interface CommonQueriesUsdcBalanceArgs {
  walletAddress: string;
}

/**
 * Runs the "usdcBalance" query on CommonQueries.
 * Description: Get USDC balance for a wallet address in base units (1 USDC = 1,000,000 base units with 6 decimals). Pass walletAddress as parameter.
 * Query Logic: @TokenPlugin.getBalance(@newData.walletAddress, @constants.USDC)
 */
export async function runUsdcBalanceQueryForCommonQueries(queryId: string, args: CommonQueriesUsdcBalanceArgs): Promise<number> {
  try {
    const result = await runQuery(`commonQueries/${queryId}`, "usdcBalance", args);
    return result as number;
  } catch (error) {
    console.error(`Error running query "usdcBalance" on CommonQueries: ${formatError(error)}`);
    throw error;
  }
}

/** Arguments accepted by the "tokenBalance" query on CommonQueries. */
interface CommonQueriesTokenBalanceArgs {
  walletAddress: string;
  tokenMint: string;
}

/**
 * Runs the "tokenBalance" query on CommonQueries.
 * Description: Get balance for any SPL token mint for a wallet address. Pass walletAddress and tokenMint as parameters. Returns balance in the token's smallest units based on its decimals.
 * Query Logic: @TokenPlugin.getBalance(@newData.walletAddress, @newData.tokenMint)
 */
export async function runTokenBalanceQueryForCommonQueries(queryId: string, args: CommonQueriesTokenBalanceArgs): Promise<number> {
  try {
    const result = await runQuery(`commonQueries/${queryId}`, "tokenBalance", args);
    return result as number;
  } catch (error) {
    console.error(`Error running query "tokenBalance" on CommonQueries: ${formatError(error)}`);
    throw error;
  }
}

/** Arguments accepted by the "jupiterSwapQuote" query on CommonQueries. */
interface CommonQueriesJupiterSwapQuoteArgs {
  inputMint: string;
  outputMint: string;
  amount: string;
}

/**
 * Runs the "jupiterSwapQuote" query on CommonQueries.
 * Description: Get a Jupiter swap quote for exchanging tokens. Pass inputMint (token to sell, use @constants.SOL for native SOL), outputMint (token to buy), and amount (in smallest units like lamports). Returns the expected output amount.
 * Query Logic: @DeFiPlugin.getSwapQuote(@newData.inputMint, @newData.outputMint, @newData.amount)
 */
export async function runJupiterSwapQuoteQueryForCommonQueries(queryId: string, args: CommonQueriesJupiterSwapQuoteArgs): Promise<number> {
  try {
    const result = await runQuery(`commonQueries/${queryId}`, "jupiterSwapQuote", args);
    return result as number;
  } catch (error) {
    console.error(`Error running query "jupiterSwapQuote" on CommonQueries: ${formatError(error)}`);
    throw error;
  }
}

/** Arguments accepted by the "meteoraSwapQuote" query on CommonQueries. */
interface CommonQueriesMeteoraSwapQuoteArgs {
  tokenMintAddress: string;
  tokenToSwapInMintAddress: string;
  tokenAmount: string;
}

/**
 * Runs the "meteoraSwapQuote" query on CommonQueries.
 * Description: Get a Meteora dynamic bonding curve swap quote. Pass tokenMintAddress (the pool's base token), tokenToSwapInMintAddress (token to swap in, use @constants.SOL for native SOL), and tokenAmount (in smallest units). Returns the expected output amount.
 * Query Logic: @DeFiPlugin.getMeteoraSwapQuote(@newData.tokenMintAddress, @newData.tokenToSwapInMintAddress, @newData.tokenAmount)
 */
export async function runMeteoraSwapQuoteQueryForCommonQueries(queryId: string, args: CommonQueriesMeteoraSwapQuoteArgs): Promise<number> {
  try {
    const result = await runQuery(`commonQueries/${queryId}`, "meteoraSwapQuote", args);
    return result as number;
  } catch (error) {
    console.error(`Error running query "meteoraSwapQuote" on CommonQueries: ${formatError(error)}`);
    throw error;
  }
}

// --- Path: lotteryPot/$potId ---

export interface LotteryPotRequest {
  active: boolean;
}

export interface LotteryPotResponse {
  active: boolean;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a LotteryPot operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryPot(potId: string, data?: LotteryPotRequest): DocumentOperation {
  const doc = data ? transformValues(data) : {};
  return { path: `lotteryPot/${potId}`, document: doc };
}

/**
 * Admin creates the lottery pot PDA once. The potId must match @constants.POT_ID. Creates the on-chain PDA account that holds SOL for prize payouts. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryPot(potId: string, data?: LotteryPotRequest): Promise<boolean> {
  try {
    const transformedData = transformValues(data || {});
    const succeeded = await set(`lotteryPot/${potId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting LotteryPot: ${formatError(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can check the prize pot balance and status.
   (Get Single Item)
 */
export async function getLotteryPot(potId: string): Promise<LotteryPotResponse | null> {
  try {
    const result = await get(`lotteryPot/${potId}`);
    return result as LotteryPotResponse | null;
  } catch (error) {
    console.error(`Error getting LotteryPot: ${formatError(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single LotteryPot document. (
  Read Operation Details: Anyone can check the prize pot balance and status.
  )
 */
export function subscribeLotteryPot(callback: (data: LotteryPotResponse | null) => void, potId: string): Promise<() => Promise<void>> {
  return subscribe(`lotteryPot/${potId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as LotteryPotResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to LotteryPot at path '${`lotteryPot/${potId}`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get many LotteryPot items from collection lotteryPot
 
  Read Operation Details: Anyone can check the prize pot balance and status.
  
 */
export async function getManyLotteryPot(filter: string = ""): Promise<LotteryPotResponse[]> {
  try {
    const results = await get("lotteryPot", { prompt: filter });
    return Array.isArray(results) ? results as LotteryPotResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryPot collection at path 'lotteryPot': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryPot collection at lotteryPot
 
  Read Operation Details: Anyone can check the prize pot balance and status.
  
 */
export function subscribeManyLotteryPot(callback: (data: LotteryPotResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("lotteryPot", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryPotResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryPot collection at path '${"lotteryPot"}': ${formatError(error)}`);
    }
  });
}

/**
 * Get all LotteryPot items from collection lotteryPot
 
  Read Operation Details: Anyone can check the prize pot balance and status.
  
 */
export async function getAllLotteryPot(filter: string = ""): Promise<LotteryPotResponse[]> {
  try {
    const results = await get("lotteryPot", { prompt: filter });
    return Array.isArray(results) ? results as LotteryPotResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryPot collection at path 'lotteryPot': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryPot collection at lotteryPot
 
  Read Operation Details: Anyone can check the prize pot balance and status.
  
 */
export function subscribeAllLotteryPot(callback: (data: LotteryPotResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("lotteryPot", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryPotResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryPot collection at path '${"lotteryPot"}': ${formatError(error)}`);
    }
  });
}

/**
 * Runs the "getPotBalance" query on LotteryPot.
 * Query Logic: @TokenPlugin.getBalance(@constants.POT_ID, @constants.SOL)
 */
export async function runGetPotBalanceQueryForLotteryPot(potId: string, ): Promise<number> {
  try {
    const result = await runQuery(`lotteryPot/${potId}`, "getPotBalance", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getPotBalance" on LotteryPot: ${formatError(error)}`);
    throw error;
  }
}

// --- Path: lotteryState/$lotteryId ---

export interface LotteryStateRequest {
  isActive: boolean;
  mainNumber: number | TimeOperation | IncrementOperation | TokenAmount;
  totalTickets: number | TimeOperation | IncrementOperation | TokenAmount;
  lastWinner?: AddressType;
  lastWinNumber?: number | TimeOperation | IncrementOperation | TokenAmount;
}

export interface LotteryStateResponse {
  isActive: boolean;
  mainNumber: number;
  totalTickets: number;
  lastWinner?: string;
  lastWinNumber?: number;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a LotteryState operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryState(lotteryId: string, data: LotteryStateRequest): DocumentOperation {
  const doc = transformValues(data);
  return { path: `lotteryState/${lotteryId}`, document: doc };
}

/**
 * Any authenticated user can create a new lottery round and request VRF to generate the main number (range 0 to u64 max via @constants.MAX_NUMBER). The round starts inactive until the VRF reveal sets the mainNumber and activates it. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryState(lotteryId: string, data: LotteryStateRequest): Promise<boolean> {
  try {
    const transformedData = transformValues(data);
    const succeeded = await set(`lotteryState/${lotteryId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting LotteryState: ${formatError(error)}`);
    return false;
  }
}

export type LotteryStateRequestUpdate = Partial<LotteryStateRequest>;

/**
 * Build a LotteryState update operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildUpdateLotteryState(lotteryId: string, data: LotteryStateRequestUpdate): DocumentOperation {
  const doc = transformValues(data);
  return { path: `lotteryState/${lotteryId}`, document: doc };
}

/**
 * Admin only. Safety valve to manually deactivate a stuck round by setting isActive to false. Reveal hooks bypass rules via @DocumentPlugin.updateField and are unaffected by this rule. (Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the update worked.
 */
export async function updateLotteryState(lotteryId: string, data: LotteryStateRequestUpdate): Promise<boolean> {
  try {
    const transformedData = transformValues(data);
    const succeeded = await set(`lotteryState/${lotteryId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error updating LotteryState: ${formatError(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
   (Get Single Item)
 */
export async function getLotteryState(lotteryId: string): Promise<LotteryStateResponse | null> {
  try {
    const result = await get(`lotteryState/${lotteryId}`);
    return result as LotteryStateResponse | null;
  } catch (error) {
    console.error(`Error getting LotteryState: ${formatError(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single LotteryState document. (
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
  )
 */
export function subscribeLotteryState(callback: (data: LotteryStateResponse | null) => void, lotteryId: string): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/${lotteryId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as LotteryStateResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to LotteryState at path '${`lotteryState/${lotteryId}`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get many LotteryState items from collection lotteryState
 
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
  
 */
export async function getManyLotteryState(filter: string = ""): Promise<LotteryStateResponse[]> {
  try {
    const results = await get("lotteryState", { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryState collection at path 'lotteryState': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryState collection at lotteryState
 
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
  
 */
export function subscribeManyLotteryState(callback: (data: LotteryStateResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("lotteryState", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryState collection at path '${"lotteryState"}': ${formatError(error)}`);
    }
  });
}

/**
 * Get all LotteryState items from collection lotteryState
 
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
  
 */
export async function getAllLotteryState(filter: string = ""): Promise<LotteryStateResponse[]> {
  try {
    const results = await get("lotteryState", { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryState collection at path 'lotteryState': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryState collection at lotteryState
 
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
  
 */
export function subscribeAllLotteryState(callback: (data: LotteryStateResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("lotteryState", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryState collection at path '${"lotteryState"}': ${formatError(error)}`);
    }
  });
}

/**
 * Runs the "getMainNumber" query on LotteryState.
 * Query Logic: @OraclePlugin.getRandomNumber($lotteryId, 0, @constants.MAX_NUMBER)
 */
export async function runGetMainNumberQueryForLotteryState(lotteryId: string, ): Promise<number> {
  try {
    const result = await runQuery(`lotteryState/${lotteryId}`, "getMainNumber", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getMainNumber" on LotteryState: ${formatError(error)}`);
    throw error;
  }
}

/**
 * Runs the "getVRFAddress" query on LotteryState.
 * Query Logic: @OraclePlugin.getVRFAddress($lotteryId)
 */
export async function runGetVRFAddressQueryForLotteryState(lotteryId: string, ): Promise<string> {
  try {
    const result = await runQuery(`lotteryState/${lotteryId}`, "getVRFAddress", {});
    return result as string;
  } catch (error) {
    console.error(`Error running query "getVRFAddress" on LotteryState: ${formatError(error)}`);
    throw error;
  }
}

// --- Path: lotteryState/$lotteryId/startReveals/$revealId ---

export interface LotteryStateStartRevealsRequest {

}

export interface LotteryStateStartRevealsResponse {

  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a LotteryStateStartReveals operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryStateStartReveals(lotteryId: string, revealId: string, data?: LotteryStateStartRevealsRequest): DocumentOperation {
  const doc = data ? transformValues(data) : {};
  return { path: `lotteryState/${lotteryId}/startReveals/${revealId}`, document: doc };
}

/**
 * Oracle VRF callback. The revealId must match lotteryId. Reads the random number for this lotteryId (0 to u64 max via @constants.MAX_NUMBER), sets it as mainNumber on the lotteryState, and activates the round. Idempotent via || true pattern. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryStateStartReveals(lotteryId: string, revealId: string, data?: LotteryStateStartRevealsRequest): Promise<boolean> {
  try {
    const transformedData = transformValues(data || {});
    const succeeded = await set(`lotteryState/${lotteryId}/startReveals/${revealId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting LotteryStateStartReveals: ${formatError(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can view reveal records (fieldless).
   (Get Single Item)
 */
export async function getLotteryStateStartReveals(lotteryId: string, revealId: string): Promise<LotteryStateStartRevealsResponse | null> {
  try {
    const result = await get(`lotteryState/${lotteryId}/startReveals/${revealId}`);
    return result as LotteryStateStartRevealsResponse | null;
  } catch (error) {
    console.error(`Error getting LotteryStateStartReveals: ${formatError(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single LotteryStateStartReveals document. (
  Read Operation Details: Anyone can view reveal records (fieldless).
  )
 */
export function subscribeLotteryStateStartReveals(callback: (data: LotteryStateStartRevealsResponse | null) => void, lotteryId: string, revealId: string): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/${lotteryId}/startReveals/${revealId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as LotteryStateStartRevealsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to LotteryStateStartReveals at path '${`lotteryState/${lotteryId}/startReveals/${revealId}`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get many LotteryStateStartReveals items from collection lotteryState/${lotteryId}/startReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export async function getManyLotteryStateStartReveals(lotteryId: string, filter: string = ""): Promise<LotteryStateStartRevealsResponse[]> {
  try {
    const results = await get(`lotteryState/${lotteryId}/startReveals`, { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateStartRevealsResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryStateStartReveals collection at path 'lotteryState/${lotteryId}/startReveals': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryStateStartReveals collection at lotteryState/${lotteryId}/startReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export function subscribeManyLotteryStateStartReveals(callback: (data: LotteryStateStartRevealsResponse[]) => void, lotteryId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/${lotteryId}/startReveals`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateStartRevealsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryStateStartReveals collection at path '${`lotteryState/${lotteryId}/startReveals`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get all LotteryStateStartReveals items from collection lotteryState/${lotteryId}/startReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export async function getAllLotteryStateStartReveals(lotteryId: string, filter: string = ""): Promise<LotteryStateStartRevealsResponse[]> {
  try {
    const results = await get(`lotteryState/*/startReveals`, { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateStartRevealsResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryStateStartReveals collection at path 'lotteryState/${lotteryId}/startReveals': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryStateStartReveals collection at lotteryState/${lotteryId}/startReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export function subscribeAllLotteryStateStartReveals(callback: (data: LotteryStateStartRevealsResponse[]) => void, lotteryId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/*/startReveals`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateStartRevealsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryStateStartReveals collection at path '${`lotteryState/*/startReveals`}': ${formatError(error)}`);
    }
  });
}

// --- Path: lotteryState/$lotteryId/tickets/$ticketId ---

export interface LotteryStateTicketsRequest {
  buyer: AddressType;
  lotteryId: string;
  won?: boolean;
  winNumber?: number | TimeOperation | IncrementOperation | TokenAmount;
}

export interface LotteryStateTicketsResponse {
  buyer: string;
  lotteryId: string;
  won?: boolean;
  winNumber?: number;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a LotteryStateTickets operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryStateTickets(lotteryId: string, ticketId: string, data?: LotteryStateTicketsRequest): DocumentOperation {
  const doc = data ? transformValues(data) : {};
  return { path: `lotteryState/${lotteryId}/tickets/${ticketId}`, document: doc };
}

/**
 * Authenticated user buys a ticket for 0.01 SOL (10000000 lamports). Lottery must be active. Buyer must equal @user.address. SOL is transferred to the pot PDA via onchain hook. VRF randomness is requested for this ticket with u64 max range. The won and winNumber fields start null and are set by the reveal hook. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryStateTickets(lotteryId: string, ticketId: string, data?: LotteryStateTicketsRequest): Promise<boolean> {
  try {
    const transformedData = transformValues(data || {});
    const succeeded = await set(`lotteryState/${lotteryId}/tickets/${ticketId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting LotteryStateTickets: ${formatError(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
   (Get Single Item)
 */
export async function getLotteryStateTickets(lotteryId: string, ticketId: string): Promise<LotteryStateTicketsResponse | null> {
  try {
    const result = await get(`lotteryState/${lotteryId}/tickets/${ticketId}`);
    return result as LotteryStateTicketsResponse | null;
  } catch (error) {
    console.error(`Error getting LotteryStateTickets: ${formatError(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single LotteryStateTickets document. (
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
  )
 */
export function subscribeLotteryStateTickets(callback: (data: LotteryStateTicketsResponse | null) => void, lotteryId: string, ticketId: string): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/${lotteryId}/tickets/${ticketId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as LotteryStateTicketsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to LotteryStateTickets at path '${`lotteryState/${lotteryId}/tickets/${ticketId}`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get many LotteryStateTickets items from collection lotteryState/${lotteryId}/tickets
 
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
  
 */
export async function getManyLotteryStateTickets(lotteryId: string, filter: string = ""): Promise<LotteryStateTicketsResponse[]> {
  try {
    const results = await get(`lotteryState/${lotteryId}/tickets`, { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateTicketsResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryStateTickets collection at path 'lotteryState/${lotteryId}/tickets': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryStateTickets collection at lotteryState/${lotteryId}/tickets
 
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
  
 */
export function subscribeManyLotteryStateTickets(callback: (data: LotteryStateTicketsResponse[]) => void, lotteryId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/${lotteryId}/tickets`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateTicketsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryStateTickets collection at path '${`lotteryState/${lotteryId}/tickets`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get all LotteryStateTickets items from collection lotteryState/${lotteryId}/tickets
 
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
  
 */
export async function getAllLotteryStateTickets(lotteryId: string, filter: string = ""): Promise<LotteryStateTicketsResponse[]> {
  try {
    const results = await get(`lotteryState/*/tickets`, { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateTicketsResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryStateTickets collection at path 'lotteryState/${lotteryId}/tickets': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryStateTickets collection at lotteryState/${lotteryId}/tickets
 
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
  
 */
export function subscribeAllLotteryStateTickets(callback: (data: LotteryStateTicketsResponse[]) => void, lotteryId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/*/tickets`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateTicketsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryStateTickets collection at path '${`lotteryState/*/tickets`}': ${formatError(error)}`);
    }
  });
}

/**
 * Runs the "getTicketNumber" query on LotteryStateTickets.
 * Query Logic: @OraclePlugin.getRandomNumber($ticketId, 0, @constants.MAX_NUMBER)
 */
export async function runGetTicketNumberQueryForLotteryStateTickets(lotteryId: string, ticketId: string, ): Promise<number> {
  try {
    const result = await runQuery(`lotteryState/${lotteryId}/tickets/${ticketId}`, "getTicketNumber", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getTicketNumber" on LotteryStateTickets: ${formatError(error)}`);
    throw error;
  }
}

/**
 * Runs the "getTicketVRFAddress" query on LotteryStateTickets.
 * Query Logic: @OraclePlugin.getVRFAddress($ticketId)
 */
export async function runGetTicketVRFAddressQueryForLotteryStateTickets(lotteryId: string, ticketId: string, ): Promise<string> {
  try {
    const result = await runQuery(`lotteryState/${lotteryId}/tickets/${ticketId}`, "getTicketVRFAddress", {});
    return result as string;
  } catch (error) {
    console.error(`Error running query "getTicketVRFAddress" on LotteryStateTickets: ${formatError(error)}`);
    throw error;
  }
}

// --- Path: lotteryState/$lotteryId/ticketReveals/$ticketId ---

export interface LotteryStateTicketRevealsRequest {

}

export interface LotteryStateTicketRevealsResponse {

  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a LotteryStateTicketReveals operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryStateTicketReveals(lotteryId: string, ticketId: string, data?: LotteryStateTicketRevealsRequest): DocumentOperation {
  const doc = data ? transformValues(data) : {};
  return { path: `lotteryState/${lotteryId}/ticketReveals/${ticketId}`, document: doc };
}

/**
 * Oracle VRF callback. Settlement logic: Reads ticket random number (0 to u64 max via @constants.MAX_NUMBER). If number > mainNumber, ticket wins - 99% of pot balance is transferred to buyer via @TokenPlugin.transfer from PDA using integer division (1% remains in pot as seed for next round), lottery deactivates, lastWinner and lastWinNumber are set on lotteryState. If number <= mainNumber, ticket is marked as lost and pot keeps growing. Uses get() for buyer field (immutable, set on ticket create). Idempotent via || true pattern and won == null guard. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryStateTicketReveals(lotteryId: string, ticketId: string, data?: LotteryStateTicketRevealsRequest): Promise<boolean> {
  try {
    const transformedData = transformValues(data || {});
    const succeeded = await set(`lotteryState/${lotteryId}/ticketReveals/${ticketId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting LotteryStateTicketReveals: ${formatError(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can view reveal records (fieldless).
   (Get Single Item)
 */
export async function getLotteryStateTicketReveals(lotteryId: string, ticketId: string): Promise<LotteryStateTicketRevealsResponse | null> {
  try {
    const result = await get(`lotteryState/${lotteryId}/ticketReveals/${ticketId}`);
    return result as LotteryStateTicketRevealsResponse | null;
  } catch (error) {
    console.error(`Error getting LotteryStateTicketReveals: ${formatError(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single LotteryStateTicketReveals document. (
  Read Operation Details: Anyone can view reveal records (fieldless).
  )
 */
export function subscribeLotteryStateTicketReveals(callback: (data: LotteryStateTicketRevealsResponse | null) => void, lotteryId: string, ticketId: string): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/${lotteryId}/ticketReveals/${ticketId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as LotteryStateTicketRevealsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to LotteryStateTicketReveals at path '${`lotteryState/${lotteryId}/ticketReveals/${ticketId}`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get many LotteryStateTicketReveals items from collection lotteryState/${lotteryId}/ticketReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export async function getManyLotteryStateTicketReveals(lotteryId: string, filter: string = ""): Promise<LotteryStateTicketRevealsResponse[]> {
  try {
    const results = await get(`lotteryState/${lotteryId}/ticketReveals`, { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateTicketRevealsResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryStateTicketReveals collection at path 'lotteryState/${lotteryId}/ticketReveals': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryStateTicketReveals collection at lotteryState/${lotteryId}/ticketReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export function subscribeManyLotteryStateTicketReveals(callback: (data: LotteryStateTicketRevealsResponse[]) => void, lotteryId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/${lotteryId}/ticketReveals`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateTicketRevealsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryStateTicketReveals collection at path '${`lotteryState/${lotteryId}/ticketReveals`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get all LotteryStateTicketReveals items from collection lotteryState/${lotteryId}/ticketReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export async function getAllLotteryStateTicketReveals(lotteryId: string, filter: string = ""): Promise<LotteryStateTicketRevealsResponse[]> {
  try {
    const results = await get(`lotteryState/*/ticketReveals`, { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateTicketRevealsResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryStateTicketReveals collection at path 'lotteryState/${lotteryId}/ticketReveals': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryStateTicketReveals collection at lotteryState/${lotteryId}/ticketReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export function subscribeAllLotteryStateTicketReveals(callback: (data: LotteryStateTicketRevealsResponse[]) => void, lotteryId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/*/ticketReveals`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateTicketRevealsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryStateTicketReveals collection at path '${`lotteryState/*/ticketReveals`}': ${formatError(error)}`);
    }
  });
}

// --- Path: lotteryPotFunding/$fundingId ---

export interface LotteryPotFundingRequest {
  amt: number | TimeOperation | IncrementOperation | TokenAmount;
}

export interface LotteryPotFundingResponse {
  amt: number;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a LotteryPotFunding operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryPotFunding(fundingId: string, data?: LotteryPotFundingRequest): DocumentOperation {
  const doc = data ? transformValues(data) : {};
  return { path: `lotteryPotFunding/${fundingId}`, document: doc };
}

/**
 * Admin only. Transfers the specified amount of SOL (in lamports) from admin wallet to the pot PDA via onchain hook. Used to seed or top up the prize pool. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryPotFunding(fundingId: string, data?: LotteryPotFundingRequest): Promise<boolean> {
  try {
    const transformedData = transformValues(data || {});
    const succeeded = await set(`lotteryPotFunding/${fundingId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting LotteryPotFunding: ${formatError(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can view funding history.
   (Get Single Item)
 */
export async function getLotteryPotFunding(fundingId: string): Promise<LotteryPotFundingResponse | null> {
  try {
    const result = await get(`lotteryPotFunding/${fundingId}`);
    return result as LotteryPotFundingResponse | null;
  } catch (error) {
    console.error(`Error getting LotteryPotFunding: ${formatError(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single LotteryPotFunding document. (
  Read Operation Details: Anyone can view funding history.
  )
 */
export function subscribeLotteryPotFunding(callback: (data: LotteryPotFundingResponse | null) => void, fundingId: string): Promise<() => Promise<void>> {
  return subscribe(`lotteryPotFunding/${fundingId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as LotteryPotFundingResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to LotteryPotFunding at path '${`lotteryPotFunding/${fundingId}`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get many LotteryPotFunding items from collection lotteryPotFunding
 
  Read Operation Details: Anyone can view funding history.
  
 */
export async function getManyLotteryPotFunding(filter: string = ""): Promise<LotteryPotFundingResponse[]> {
  try {
    const results = await get("lotteryPotFunding", { prompt: filter });
    return Array.isArray(results) ? results as LotteryPotFundingResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryPotFunding collection at path 'lotteryPotFunding': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryPotFunding collection at lotteryPotFunding
 
  Read Operation Details: Anyone can view funding history.
  
 */
export function subscribeManyLotteryPotFunding(callback: (data: LotteryPotFundingResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("lotteryPotFunding", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryPotFundingResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryPotFunding collection at path '${"lotteryPotFunding"}': ${formatError(error)}`);
    }
  });
}

/**
 * Get all LotteryPotFunding items from collection lotteryPotFunding
 
  Read Operation Details: Anyone can view funding history.
  
 */
export async function getAllLotteryPotFunding(filter: string = ""): Promise<LotteryPotFundingResponse[]> {
  try {
    const results = await get("lotteryPotFunding", { prompt: filter });
    return Array.isArray(results) ? results as LotteryPotFundingResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryPotFunding collection at path 'lotteryPotFunding': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryPotFunding collection at lotteryPotFunding
 
  Read Operation Details: Anyone can view funding history.
  
 */
export function subscribeAllLotteryPotFunding(callback: (data: LotteryPotFundingResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("lotteryPotFunding", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryPotFundingResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryPotFunding collection at path '${"lotteryPotFunding"}': ${formatError(error)}`);
    }
  });
}

// --- End Generated SDK ---
