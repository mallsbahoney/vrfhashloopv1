// Generated by TaroBase SDK Generator: 2026-02-27T08:07:59.727Z
// Collection: lotteryPot/$potId
// Edits may be overwritten by subsequent runs!

import {
  get, set, subscribe, getFiles, setFile, runQuery, transformValues,
  Time, Token, Increment, Address, PublicKey,
  TimeOperation, IncrementOperation, TokenAmount, AddressType,
  TarobaseMetadata, DocumentOperation, FileItem, setMany, formatError,
} from '../db-client';

/**
 * Prize pool escrow PDA that holds all ticket purchase SOL
 */

export interface LotteryPotRequest {
  active: boolean;
}

export interface LotteryPotResponse {
  active: boolean;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a LotteryPot operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryPot(potId: string, data?: LotteryPotRequest): DocumentOperation {
  const doc = data ? transformValues(data) : {};
  return { path: `lotteryPot/${potId}`, document: doc };
}

/**
 * Admin creates the lottery pot PDA once. The potId must match @constants.POT_ID. Creates the on-chain PDA account that holds SOL for prize payouts. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryPot(potId: string, data?: LotteryPotRequest): Promise<boolean> {
  try {
    const transformedData = transformValues(data || {});
    const succeeded = await set(`lotteryPot/${potId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting LotteryPot: ${formatError(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can check the prize pot balance and status.
   (Get Single Item)
 */
export async function getLotteryPot(potId: string): Promise<LotteryPotResponse | null> {
  try {
    const result = await get(`lotteryPot/${potId}`);
    return result as LotteryPotResponse | null;
  } catch (error) {
    console.error(`Error getting LotteryPot: ${formatError(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single LotteryPot document. (
  Read Operation Details: Anyone can check the prize pot balance and status.
  )
 */
export function subscribeLotteryPot(callback: (data: LotteryPotResponse | null) => void, potId: string): Promise<() => Promise<void>> {
  return subscribe(`lotteryPot/${potId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as LotteryPotResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to LotteryPot at path '${`lotteryPot/${potId}`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get many LotteryPot items from collection lotteryPot
 
  Read Operation Details: Anyone can check the prize pot balance and status.
  
 */
export async function getManyLotteryPot(filter: string = ""): Promise<LotteryPotResponse[]> {
  try {
    const results = await get("lotteryPot", { prompt: filter });
    return Array.isArray(results) ? results as LotteryPotResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryPot collection at path 'lotteryPot': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryPot collection at lotteryPot
 
  Read Operation Details: Anyone can check the prize pot balance and status.
  
 */
export function subscribeManyLotteryPot(callback: (data: LotteryPotResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("lotteryPot", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryPotResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryPot collection at path '${"lotteryPot"}': ${formatError(error)}`);
    }
  });
}

/**
 * Get all LotteryPot items from collection lotteryPot
 
  Read Operation Details: Anyone can check the prize pot balance and status.
  
 */
export async function getAllLotteryPot(filter: string = ""): Promise<LotteryPotResponse[]> {
  try {
    const results = await get("lotteryPot", { prompt: filter });
    return Array.isArray(results) ? results as LotteryPotResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryPot collection at path 'lotteryPot': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryPot collection at lotteryPot
 
  Read Operation Details: Anyone can check the prize pot balance and status.
  
 */
export function subscribeAllLotteryPot(callback: (data: LotteryPotResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("lotteryPot", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryPotResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryPot collection at path '${"lotteryPot"}': ${formatError(error)}`);
    }
  });
}

/**
 * Runs the "getPotBalance" query on LotteryPot.
 * Query Logic: @TokenPlugin.getBalance(@constants.POT_ID, @constants.SOL)
 */
export async function runGetPotBalanceQueryForLotteryPot(potId: string, ): Promise<number> {
  try {
    const result = await runQuery(`lotteryPot/${potId}`, "getPotBalance", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getPotBalance" on LotteryPot: ${formatError(error)}`);
    throw error;
  }
}

