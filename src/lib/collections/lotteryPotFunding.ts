// Generated by TaroBase SDK Generator: 2026-02-27T08:07:59.727Z
// Collection: lotteryPotFunding/$fundingId
// Edits may be overwritten by subsequent runs!

import {
  get, set, subscribe, getFiles, setFile, runQuery, transformValues,
  Time, Token, Increment, Address, PublicKey,
  TimeOperation, IncrementOperation, TokenAmount, AddressType,
  TarobaseMetadata, DocumentOperation, FileItem, setMany, formatError,
} from '../db-client';

/**
 * Admin seeds the prize pot with additional SOL
 */

export interface LotteryPotFundingRequest {
  amt: number | TimeOperation | IncrementOperation | TokenAmount;
}

export interface LotteryPotFundingResponse {
  amt: number;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a LotteryPotFunding operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryPotFunding(fundingId: string, data?: LotteryPotFundingRequest): DocumentOperation {
  const doc = data ? transformValues(data) : {};
  return { path: `lotteryPotFunding/${fundingId}`, document: doc };
}

/**
 * Admin only. Transfers the specified amount of SOL (in lamports) from admin wallet to the pot PDA via onchain hook. Used to seed or top up the prize pool. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryPotFunding(fundingId: string, data?: LotteryPotFundingRequest): Promise<boolean> {
  try {
    const transformedData = transformValues(data || {});
    const succeeded = await set(`lotteryPotFunding/${fundingId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting LotteryPotFunding: ${formatError(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can view funding history.
   (Get Single Item)
 */
export async function getLotteryPotFunding(fundingId: string): Promise<LotteryPotFundingResponse | null> {
  try {
    const result = await get(`lotteryPotFunding/${fundingId}`);
    return result as LotteryPotFundingResponse | null;
  } catch (error) {
    console.error(`Error getting LotteryPotFunding: ${formatError(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single LotteryPotFunding document. (
  Read Operation Details: Anyone can view funding history.
  )
 */
export function subscribeLotteryPotFunding(callback: (data: LotteryPotFundingResponse | null) => void, fundingId: string): Promise<() => Promise<void>> {
  return subscribe(`lotteryPotFunding/${fundingId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as LotteryPotFundingResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to LotteryPotFunding at path '${`lotteryPotFunding/${fundingId}`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get many LotteryPotFunding items from collection lotteryPotFunding
 
  Read Operation Details: Anyone can view funding history.
  
 */
export async function getManyLotteryPotFunding(filter: string = ""): Promise<LotteryPotFundingResponse[]> {
  try {
    const results = await get("lotteryPotFunding", { prompt: filter });
    return Array.isArray(results) ? results as LotteryPotFundingResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryPotFunding collection at path 'lotteryPotFunding': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryPotFunding collection at lotteryPotFunding
 
  Read Operation Details: Anyone can view funding history.
  
 */
export function subscribeManyLotteryPotFunding(callback: (data: LotteryPotFundingResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("lotteryPotFunding", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryPotFundingResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryPotFunding collection at path '${"lotteryPotFunding"}': ${formatError(error)}`);
    }
  });
}

/**
 * Get all LotteryPotFunding items from collection lotteryPotFunding
 
  Read Operation Details: Anyone can view funding history.
  
 */
export async function getAllLotteryPotFunding(filter: string = ""): Promise<LotteryPotFundingResponse[]> {
  try {
    const results = await get("lotteryPotFunding", { prompt: filter });
    return Array.isArray(results) ? results as LotteryPotFundingResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryPotFunding collection at path 'lotteryPotFunding': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryPotFunding collection at lotteryPotFunding
 
  Read Operation Details: Anyone can view funding history.
  
 */
export function subscribeAllLotteryPotFunding(callback: (data: LotteryPotFundingResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("lotteryPotFunding", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryPotFundingResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryPotFunding collection at path '${"lotteryPotFunding"}': ${formatError(error)}`);
    }
  });
}

