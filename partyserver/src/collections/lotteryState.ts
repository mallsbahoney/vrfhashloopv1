// Generated by TaroBase SDK Generator: 2026-02-27T08:07:59.732Z
// Collection: lotteryState/$lotteryId
// Edits may be overwritten by subsequent runs!

import {
  get, set, subscribe, getFiles, setFile, runQuery, transformValues,
  Time, Token, Increment, Address, PublicKey,
  TimeOperation, IncrementOperation, TokenAmount, AddressType,
  TarobaseMetadata, DocumentOperation, FileItem, setMany, formatError,
} from '../db-client';

/**
 * Current lottery round state - tracks active status, main number to beat, tickets count, and last winner
 */

export interface LotteryStateRequest {
  isActive: boolean;
  mainNumber: number | TimeOperation | IncrementOperation | TokenAmount;
  totalTickets: number | TimeOperation | IncrementOperation | TokenAmount;
  lastWinner?: AddressType;
  lastWinNumber?: number | TimeOperation | IncrementOperation | TokenAmount;
}

export interface LotteryStateResponse {
  isActive: boolean;
  mainNumber: number;
  totalTickets: number;
  lastWinner?: string;
  lastWinNumber?: number;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a LotteryState operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryState(lotteryId: string, data: LotteryStateRequest): DocumentOperation {
  const doc = transformValues(data);
  return { path: `lotteryState/${lotteryId}`, document: doc };
}

/**
 * Any authenticated user can create a new lottery round and request VRF to generate the main number (range 0 to u64 max via @constants.MAX_NUMBER). The round starts inactive until the VRF reveal sets the mainNumber and activates it. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryState(lotteryId: string, data: LotteryStateRequest): Promise<boolean> {
  try {
    const transformedData = transformValues(data);
    const succeeded = await set(`lotteryState/${lotteryId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting LotteryState: ${formatError(error)}`);
    return false;
  }
}

export type LotteryStateRequestUpdate = Partial<LotteryStateRequest>;

/**
 * Build a LotteryState update operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildUpdateLotteryState(lotteryId: string, data: LotteryStateRequestUpdate): DocumentOperation {
  const doc = transformValues(data);
  return { path: `lotteryState/${lotteryId}`, document: doc };
}

/**
 * Admin only. Safety valve to manually deactivate a stuck round by setting isActive to false. Reveal hooks bypass rules via @DocumentPlugin.updateField and are unaffected by this rule. (Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the update worked.
 */
export async function updateLotteryState(lotteryId: string, data: LotteryStateRequestUpdate): Promise<boolean> {
  try {
    const transformedData = transformValues(data);
    const succeeded = await set(`lotteryState/${lotteryId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error updating LotteryState: ${formatError(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
   (Get Single Item)
 */
export async function getLotteryState(lotteryId: string): Promise<LotteryStateResponse | null> {
  try {
    const result = await get(`lotteryState/${lotteryId}`);
    return result as LotteryStateResponse | null;
  } catch (error) {
    console.error(`Error getting LotteryState: ${formatError(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single LotteryState document. (
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
  )
 */
export function subscribeLotteryState(callback: (data: LotteryStateResponse | null) => void, lotteryId: string): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/${lotteryId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as LotteryStateResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to LotteryState at path '${`lotteryState/${lotteryId}`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get many LotteryState items from collection lotteryState
 
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
  
 */
export async function getManyLotteryState(filter: string = ""): Promise<LotteryStateResponse[]> {
  try {
    const results = await get("lotteryState", { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryState collection at path 'lotteryState': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryState collection at lotteryState
 
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
  
 */
export function subscribeManyLotteryState(callback: (data: LotteryStateResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("lotteryState", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryState collection at path '${"lotteryState"}': ${formatError(error)}`);
    }
  });
}

/**
 * Get all LotteryState items from collection lotteryState
 
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
  
 */
export async function getAllLotteryState(filter: string = ""): Promise<LotteryStateResponse[]> {
  try {
    const results = await get("lotteryState", { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryState collection at path 'lotteryState': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryState collection at lotteryState
 
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
  
 */
export function subscribeAllLotteryState(callback: (data: LotteryStateResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("lotteryState", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryState collection at path '${"lotteryState"}': ${formatError(error)}`);
    }
  });
}

/**
 * Runs the "getMainNumber" query on LotteryState.
 * Query Logic: @OraclePlugin.getRandomNumber($lotteryId, 0, @constants.MAX_NUMBER)
 */
export async function runGetMainNumberQueryForLotteryState(lotteryId: string, ): Promise<number> {
  try {
    const result = await runQuery(`lotteryState/${lotteryId}`, "getMainNumber", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getMainNumber" on LotteryState: ${formatError(error)}`);
    throw error;
  }
}

/**
 * Runs the "getVRFAddress" query on LotteryState.
 * Query Logic: @OraclePlugin.getVRFAddress($lotteryId)
 */
export async function runGetVRFAddressQueryForLotteryState(lotteryId: string, ): Promise<string> {
  try {
    const result = await runQuery(`lotteryState/${lotteryId}`, "getVRFAddress", {});
    return result as string;
  } catch (error) {
    console.error(`Error running query "getVRFAddress" on LotteryState: ${formatError(error)}`);
    throw error;
  }
}



/**
 * VRF reveal callback for starting the lottery - sets the main number and activates the round
 */

export interface LotteryStateStartRevealsRequest {

}

export interface LotteryStateStartRevealsResponse {

  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a LotteryStateStartReveals operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryStateStartReveals(lotteryId: string, revealId: string, data?: LotteryStateStartRevealsRequest): DocumentOperation {
  const doc = data ? transformValues(data) : {};
  return { path: `lotteryState/${lotteryId}/startReveals/${revealId}`, document: doc };
}

/**
 * Oracle VRF callback. The revealId must match lotteryId. Reads the random number for this lotteryId (0 to u64 max via @constants.MAX_NUMBER), sets it as mainNumber on the lotteryState, and activates the round. Idempotent via || true pattern. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryStateStartReveals(lotteryId: string, revealId: string, data?: LotteryStateStartRevealsRequest): Promise<boolean> {
  try {
    const transformedData = transformValues(data || {});
    const succeeded = await set(`lotteryState/${lotteryId}/startReveals/${revealId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting LotteryStateStartReveals: ${formatError(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can view reveal records (fieldless).
   (Get Single Item)
 */
export async function getLotteryStateStartReveals(lotteryId: string, revealId: string): Promise<LotteryStateStartRevealsResponse | null> {
  try {
    const result = await get(`lotteryState/${lotteryId}/startReveals/${revealId}`);
    return result as LotteryStateStartRevealsResponse | null;
  } catch (error) {
    console.error(`Error getting LotteryStateStartReveals: ${formatError(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single LotteryStateStartReveals document. (
  Read Operation Details: Anyone can view reveal records (fieldless).
  )
 */
export function subscribeLotteryStateStartReveals(callback: (data: LotteryStateStartRevealsResponse | null) => void, lotteryId: string, revealId: string): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/${lotteryId}/startReveals/${revealId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as LotteryStateStartRevealsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to LotteryStateStartReveals at path '${`lotteryState/${lotteryId}/startReveals/${revealId}`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get many LotteryStateStartReveals items from collection lotteryState/${lotteryId}/startReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export async function getManyLotteryStateStartReveals(lotteryId: string, filter: string = ""): Promise<LotteryStateStartRevealsResponse[]> {
  try {
    const results = await get(`lotteryState/${lotteryId}/startReveals`, { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateStartRevealsResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryStateStartReveals collection at path 'lotteryState/${lotteryId}/startReveals': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryStateStartReveals collection at lotteryState/${lotteryId}/startReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export function subscribeManyLotteryStateStartReveals(callback: (data: LotteryStateStartRevealsResponse[]) => void, lotteryId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/${lotteryId}/startReveals`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateStartRevealsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryStateStartReveals collection at path '${`lotteryState/${lotteryId}/startReveals`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get all LotteryStateStartReveals items from collection lotteryState/${lotteryId}/startReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export async function getAllLotteryStateStartReveals(lotteryId: string, filter: string = ""): Promise<LotteryStateStartRevealsResponse[]> {
  try {
    const results = await get(`lotteryState/*/startReveals`, { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateStartRevealsResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryStateStartReveals collection at path 'lotteryState/${lotteryId}/startReveals': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryStateStartReveals collection at lotteryState/${lotteryId}/startReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export function subscribeAllLotteryStateStartReveals(callback: (data: LotteryStateStartRevealsResponse[]) => void, lotteryId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/*/startReveals`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateStartRevealsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryStateStartReveals collection at path '${`lotteryState/*/startReveals`}': ${formatError(error)}`);
    }
  });
}



/**
 * Individual ticket purchase - each ticket costs 0.01 SOL and generates a VRF random number
 */

export interface LotteryStateTicketsRequest {
  buyer: AddressType;
  lotteryId: string;
  won?: boolean;
  winNumber?: number | TimeOperation | IncrementOperation | TokenAmount;
}

export interface LotteryStateTicketsResponse {
  buyer: string;
  lotteryId: string;
  won?: boolean;
  winNumber?: number;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a LotteryStateTickets operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryStateTickets(lotteryId: string, ticketId: string, data?: LotteryStateTicketsRequest): DocumentOperation {
  const doc = data ? transformValues(data) : {};
  return { path: `lotteryState/${lotteryId}/tickets/${ticketId}`, document: doc };
}

/**
 * Authenticated user buys a ticket for 0.01 SOL (10000000 lamports). Lottery must be active. Buyer must equal @user.address. SOL is transferred to the pot PDA via onchain hook. VRF randomness is requested for this ticket with u64 max range. The won and winNumber fields start null and are set by the reveal hook. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryStateTickets(lotteryId: string, ticketId: string, data?: LotteryStateTicketsRequest): Promise<boolean> {
  try {
    const transformedData = transformValues(data || {});
    const succeeded = await set(`lotteryState/${lotteryId}/tickets/${ticketId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting LotteryStateTickets: ${formatError(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
   (Get Single Item)
 */
export async function getLotteryStateTickets(lotteryId: string, ticketId: string): Promise<LotteryStateTicketsResponse | null> {
  try {
    const result = await get(`lotteryState/${lotteryId}/tickets/${ticketId}`);
    return result as LotteryStateTicketsResponse | null;
  } catch (error) {
    console.error(`Error getting LotteryStateTickets: ${formatError(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single LotteryStateTickets document. (
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
  )
 */
export function subscribeLotteryStateTickets(callback: (data: LotteryStateTicketsResponse | null) => void, lotteryId: string, ticketId: string): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/${lotteryId}/tickets/${ticketId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as LotteryStateTicketsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to LotteryStateTickets at path '${`lotteryState/${lotteryId}/tickets/${ticketId}`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get many LotteryStateTickets items from collection lotteryState/${lotteryId}/tickets
 
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
  
 */
export async function getManyLotteryStateTickets(lotteryId: string, filter: string = ""): Promise<LotteryStateTicketsResponse[]> {
  try {
    const results = await get(`lotteryState/${lotteryId}/tickets`, { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateTicketsResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryStateTickets collection at path 'lotteryState/${lotteryId}/tickets': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryStateTickets collection at lotteryState/${lotteryId}/tickets
 
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
  
 */
export function subscribeManyLotteryStateTickets(callback: (data: LotteryStateTicketsResponse[]) => void, lotteryId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/${lotteryId}/tickets`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateTicketsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryStateTickets collection at path '${`lotteryState/${lotteryId}/tickets`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get all LotteryStateTickets items from collection lotteryState/${lotteryId}/tickets
 
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
  
 */
export async function getAllLotteryStateTickets(lotteryId: string, filter: string = ""): Promise<LotteryStateTicketsResponse[]> {
  try {
    const results = await get(`lotteryState/*/tickets`, { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateTicketsResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryStateTickets collection at path 'lotteryState/${lotteryId}/tickets': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryStateTickets collection at lotteryState/${lotteryId}/tickets
 
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
  
 */
export function subscribeAllLotteryStateTickets(callback: (data: LotteryStateTicketsResponse[]) => void, lotteryId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/*/tickets`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateTicketsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryStateTickets collection at path '${`lotteryState/*/tickets`}': ${formatError(error)}`);
    }
  });
}

/**
 * Runs the "getTicketNumber" query on LotteryStateTickets.
 * Query Logic: @OraclePlugin.getRandomNumber($ticketId, 0, @constants.MAX_NUMBER)
 */
export async function runGetTicketNumberQueryForLotteryStateTickets(lotteryId: string, ticketId: string, ): Promise<number> {
  try {
    const result = await runQuery(`lotteryState/${lotteryId}/tickets/${ticketId}`, "getTicketNumber", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getTicketNumber" on LotteryStateTickets: ${formatError(error)}`);
    throw error;
  }
}

/**
 * Runs the "getTicketVRFAddress" query on LotteryStateTickets.
 * Query Logic: @OraclePlugin.getVRFAddress($ticketId)
 */
export async function runGetTicketVRFAddressQueryForLotteryStateTickets(lotteryId: string, ticketId: string, ): Promise<string> {
  try {
    const result = await runQuery(`lotteryState/${lotteryId}/tickets/${ticketId}`, "getTicketVRFAddress", {});
    return result as string;
  } catch (error) {
    console.error(`Error running query "getTicketVRFAddress" on LotteryStateTickets: ${formatError(error)}`);
    throw error;
  }
}



/**
 * VRF reveal callback for ticket settlement - determines if ticket wins by comparing random number to mainNumber
 */

export interface LotteryStateTicketRevealsRequest {

}

export interface LotteryStateTicketRevealsResponse {

  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a LotteryStateTicketReveals operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryStateTicketReveals(lotteryId: string, ticketId: string, data?: LotteryStateTicketRevealsRequest): DocumentOperation {
  const doc = data ? transformValues(data) : {};
  return { path: `lotteryState/${lotteryId}/ticketReveals/${ticketId}`, document: doc };
}

/**
 * Oracle VRF callback. Settlement logic: Reads ticket random number (0 to u64 max via @constants.MAX_NUMBER). If number > mainNumber, ticket wins - 99% of pot balance is transferred to buyer via @TokenPlugin.transfer from PDA using integer division (1% remains in pot as seed for next round), lottery deactivates, lastWinner and lastWinNumber are set on lotteryState. If number <= mainNumber, ticket is marked as lost and pot keeps growing. Uses get() for buyer field (immutable, set on ticket create). Idempotent via || true pattern and won == null guard. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryStateTicketReveals(lotteryId: string, ticketId: string, data?: LotteryStateTicketRevealsRequest): Promise<boolean> {
  try {
    const transformedData = transformValues(data || {});
    const succeeded = await set(`lotteryState/${lotteryId}/ticketReveals/${ticketId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting LotteryStateTicketReveals: ${formatError(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can view reveal records (fieldless).
   (Get Single Item)
 */
export async function getLotteryStateTicketReveals(lotteryId: string, ticketId: string): Promise<LotteryStateTicketRevealsResponse | null> {
  try {
    const result = await get(`lotteryState/${lotteryId}/ticketReveals/${ticketId}`);
    return result as LotteryStateTicketRevealsResponse | null;
  } catch (error) {
    console.error(`Error getting LotteryStateTicketReveals: ${formatError(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single LotteryStateTicketReveals document. (
  Read Operation Details: Anyone can view reveal records (fieldless).
  )
 */
export function subscribeLotteryStateTicketReveals(callback: (data: LotteryStateTicketRevealsResponse | null) => void, lotteryId: string, ticketId: string): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/${lotteryId}/ticketReveals/${ticketId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as LotteryStateTicketRevealsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to LotteryStateTicketReveals at path '${`lotteryState/${lotteryId}/ticketReveals/${ticketId}`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get many LotteryStateTicketReveals items from collection lotteryState/${lotteryId}/ticketReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export async function getManyLotteryStateTicketReveals(lotteryId: string, filter: string = ""): Promise<LotteryStateTicketRevealsResponse[]> {
  try {
    const results = await get(`lotteryState/${lotteryId}/ticketReveals`, { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateTicketRevealsResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryStateTicketReveals collection at path 'lotteryState/${lotteryId}/ticketReveals': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryStateTicketReveals collection at lotteryState/${lotteryId}/ticketReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export function subscribeManyLotteryStateTicketReveals(callback: (data: LotteryStateTicketRevealsResponse[]) => void, lotteryId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/${lotteryId}/ticketReveals`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateTicketRevealsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryStateTicketReveals collection at path '${`lotteryState/${lotteryId}/ticketReveals`}': ${formatError(error)}`);
    }
  });
}

/**
 * Get all LotteryStateTicketReveals items from collection lotteryState/${lotteryId}/ticketReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export async function getAllLotteryStateTicketReveals(lotteryId: string, filter: string = ""): Promise<LotteryStateTicketRevealsResponse[]> {
  try {
    const results = await get(`lotteryState/*/ticketReveals`, { prompt: filter });
    return Array.isArray(results) ? results as LotteryStateTicketRevealsResponse[] : [];
  } catch (error) {
    console.error(`Error getting LotteryStateTicketReveals collection at path 'lotteryState/${lotteryId}/ticketReveals': ${formatError(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in LotteryStateTicketReveals collection at lotteryState/${lotteryId}/ticketReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export function subscribeAllLotteryStateTicketReveals(callback: (data: LotteryStateTicketRevealsResponse[]) => void, lotteryId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`lotteryState/*/ticketReveals`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as LotteryStateTicketRevealsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to LotteryStateTicketReveals collection at path '${`lotteryState/*/ticketReveals`}': ${formatError(error)}`);
    }
  });
}

