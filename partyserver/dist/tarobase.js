// Generated by TaroBase SDK Generator: 2026-02-27T07:56:22.610Z
// Edits may be overwritten by subsequent runs!
import { get, set, subscribe, setMany as tarobaseSetMany } from '@pooflabs/server';
import { getFiles, setFile } from '@pooflabs/server';
import { PublicKey } from '@solana/web3.js';
import { runQuery } from '@pooflabs/server';
// --- SDK Utilities ---
/**
 * Helper function to check if a value is a Time.Now value
 */
const isServerTimeNow = (value) => {
    return (value &&
        typeof value === "object" &&
        value.operation === "time" &&
        value.value === "now");
};
/**
 * Helper function to check if a value is an Increment operation
 */
const isIncrementOperation = (value) => {
    return (value &&
        typeof value === "object" &&
        value.operation === "increment" &&
        typeof value.value === "number");
};
/**
 * Helper function to check if a value is a TokenAmount value
 */
const isTokenAmount = (value) => {
    return value && typeof value === 'object' && value.type === 'token';
};
/**
 * Helper function to check if a value is an AddressType value
 */
const isAddressType = (value) => {
    // Check for the 'address' type property and that publicKey is an instance of PublicKey
    return value && typeof value === 'object' && value.type === 'address';
};
/**
 * Transforms special values (Time.now, Token.amount, Address.publicKey) in an object
 * to the format expected by the backend before sending the request.
 * This function is recursive and handles nested objects and arrays.
 */
const transformValues = (data) => {
    // Handle null or non-object/array types directly
    if (!data || typeof data !== 'object') {
        return data;
    }
    // Check for specific object types first using type guards
    if (isServerTimeNow(data)) {
        // Pass Time.Now object as is; backend interprets it
        return { operation: 'time', value: 'now' };
    }
    else if (isIncrementOperation(data)) {
        // Pass Increment operation as is; backend interprets it
        return { operation: 'increment', value: data.value };
    }
    else if (isTokenAmount(data)) {
        // Convert user-friendly amount to backend's integer format based on decimals
        const { name, amount } = data; // Safe access due to type guard
        if (name === 'USDC') {
            return Math.round(amount * 10 ** 6); // 6 decimals for USDC
        }
        else if (name === 'SOL' || name === 'pSOL') {
            return Math.round(amount * 10 ** 9); // 9 decimals for SOL
        }
        else {
            // Assume a default of 6 decimals for custom tokens
            return Math.round(amount * 10 ** 6);
        }
    }
    else if (isAddressType(data)) {
        // Convert AddressType to its base58 string representation for the backend
        if (typeof data.publicKey === 'string') {
            return data.publicKey;
        }
        else {
            return data.publicKey.toBase58(); // Safe access due to type guard
        }
    }
    // Handle arrays: recursively transform each item
    if (Array.isArray(data)) {
        // Use map with explicit typing for clarity
        return data.map((item) => transformValues(item));
    }
    // Handle regular objects: recursively transform each property
    // Create a new object to avoid modifying the original
    const result = {};
    for (const key in data) {
        // Use safer check for own properties
        if (Object.prototype.hasOwnProperty.call(data, key)) {
            result[key] = transformValues(data[key]);
        }
    }
    return result;
};
// --- SDK Helper Objects ---
export const Token = {
    amount: (name, amount) => ({
        type: 'token',
        name,
        amount,
    }),
    convert: (amount) => {
        // This logic mirrors the transformation in transformValues
        if (amount.name === 'USDC') {
            return Math.round(amount.amount * 10 ** 6);
        }
        else if (amount.name === 'SOL' || amount.name === 'pSOL') {
            return Math.round(amount.amount * 10 ** 9);
        }
        return Math.round(amount.amount * 10 ** 6); // Default or handle 'other'
    },
};
export const Time = {
    Now: { operation: "time", value: "now" }
};
export const Increment = {
    by: (value) => ({
        operation: "increment",
        value
    })
};
export const Address = {
    publicKey: (key) => {
        if (typeof key === 'string') {
            // Special case: 'solana' represents native SOL asset
            if (key === 'solana') {
                return {
                    type: 'address',
                    publicKey: 'solana',
                };
            }
            // Validate format: Solana addresses are 32-44 base58 characters
            if (key.length < 32 || key.length > 44) {
                throw new Error(`Invalid Solana address length: ${key.length}. Must be 32-44 characters.`);
            }
            const base58Regex = /^[1-9A-HJ-NP-Za-km-z]+$/;
            if (!base58Regex.test(key)) {
                throw new Error(`Invalid Solana address: contains invalid characters. Must be base58 encoded.`);
            }
            try {
                // Validate and create PublicKey from string
                const pkInstance = new PublicKey(key);
                return {
                    type: 'address',
                    publicKey: pkInstance,
                };
            }
            catch (e) {
                // Safer error handling
                const message = e instanceof Error ? e.message : String(e);
                console.error(`Invalid public key string provided: ${key}`, message);
                throw new Error(`Invalid public key string: ${key}. ${message}`);
            }
        }
        else if (key instanceof PublicKey) {
            return {
                type: 'address',
                publicKey: key,
            };
        }
        else {
            // Handle invalid input type
            throw new Error('Invalid input for Address.publicKey: Must be a PublicKey instance or a base58 string.');
        }
    },
};
// --- Batch Operations ---
/**
 * Execute multiple document operations in a single batch.
 * @param operations Array of DocumentOperation objects created by build functions
 * @returns Promise resolving to the result of the batch operation
 */
export async function setMany(operations) {
    return await tarobaseSetMany(operations);
}
// --- Error Formatting ---
/**
 * Safely format an error for logging (avoids [object Object] in logs)
 * Handles circular references, empty messages, and non-Error objects
 * Always includes the full error object for comprehensive debugging
 */
export function formatError(error) {
    if (error === null)
        return 'null';
    if (error === undefined)
        return 'undefined';
    if (typeof error === 'string')
        return error || 'Empty error string';
    // For Error instances, prepend the message for readability
    const prefix = error instanceof Error ? `${error.message?.trim() || 'No message'} | Full error: ` : '';
    try {
        // Use Object.getOwnPropertyNames to include non-enumerable properties (like Error's name, message, stack)
        const str = JSON.stringify(error, Object.getOwnPropertyNames(error), 2);
        return prefix + (str || 'Empty object');
    }
    catch {
        // Circular reference or other stringify error
        return prefix + 'Unserializable error';
    }
}
// --- Generated Functions by Policy Path ---
// --- Path: adminFiles/$fileId ---
/**
 * Handles AdminFiles files (Get Single File based on its ID, null if not found)
 */
export async function getAdminFiles(fileId) {
    try {
        const rawResult = await getFiles(`adminFiles/${fileId}`);
        if (!rawResult || !Array.isArray(rawResult) || rawResult.length === 0)
            return null;
        return rawResult[0];
    }
    catch (error) {
        console.error(`Error getting file AdminFiles: ${formatError(error)}`);
        return null;
    }
}
/**
 * Handles AdminFiles files (Upload/Replace a File and persist it keyed by its ID) To get the file URL use the getAdminFiles function right after this one.
 * @returns A boolean indicating whether the upload succeeded (true) or failed (false). Always check this value to confirm the upload worked.
 */
export async function uploadAdminFiles(fileId, file) {
    try {
        const pathUsed = `adminFiles/${fileId}`;
        const result = await setFile(pathUsed, file);
        return !!result;
    }
    catch (error) {
        console.error(`Error uploading file AdminFiles: ${formatError(error)}`);
        return false;
    }
}
/**
 * Handles AdminFiles files (Delete File based on its ID)
 * @returns A boolean indicating whether the delete succeeded (true) or failed (false). Always check this value to confirm the delete worked.
 */
export async function deleteAdminFiles(fileId) {
    try {
        await setFile(`adminFiles/${fileId}`, null);
        return true;
    }
    catch (error) {
        console.error(`Error deleting file AdminFiles: ${formatError(error)}`);
        return false;
    }
}
// --- Path: appFiles/$fileId ---
/**
 * Handles AppFiles files (Get Single File based on its ID, null if not found)
 */
export async function getAppFiles(fileId) {
    try {
        const rawResult = await getFiles(`appFiles/${fileId}`);
        if (!rawResult || !Array.isArray(rawResult) || rawResult.length === 0)
            return null;
        return rawResult[0];
    }
    catch (error) {
        console.error(`Error getting file AppFiles: ${formatError(error)}`);
        return null;
    }
}
/**
 * Handles AppFiles files (Upload/Replace a File and persist it keyed by its ID) To get the file URL use the getAppFiles function right after this one.
 * @returns A boolean indicating whether the upload succeeded (true) or failed (false). Always check this value to confirm the upload worked.
 */
export async function uploadAppFiles(fileId, file) {
    try {
        const pathUsed = `appFiles/${fileId}`;
        const result = await setFile(pathUsed, file);
        return !!result;
    }
    catch (error) {
        console.error(`Error uploading file AppFiles: ${formatError(error)}`);
        return false;
    }
}
/**
 * Handles AppFiles files (Delete File based on its ID)
 * @returns A boolean indicating whether the delete succeeded (true) or failed (false). Always check this value to confirm the delete worked.
 */
export async function deleteAppFiles(fileId) {
    try {
        await setFile(`appFiles/${fileId}`, null);
        return true;
    }
    catch (error) {
        console.error(`Error deleting file AppFiles: ${formatError(error)}`);
        return false;
    }
}
/**
 *
  Read Operation Details: Anyone can use these queries: (1) Balance queries - check SOL, USDC, or any SPL token balance for any wallet address. (2) Jupiter swap quotes - get expected output amounts for token swaps via Jupiter aggregator. (3) Meteora swap quotes - get expected output amounts for Meteora dynamic bonding curve pools.
   (Get Single Item)
 */
export async function getCommonQueries(queryId) {
    try {
        const result = await get(`commonQueries/${queryId}`);
        return result;
    }
    catch (error) {
        console.error(`Error getting CommonQueries: ${formatError(error)}`);
        return null;
    }
}
/**
 * Subscribes to changes in a single CommonQueries document. (
  Read Operation Details: Anyone can use these queries: (1) Balance queries - check SOL, USDC, or any SPL token balance for any wallet address. (2) Jupiter swap quotes - get expected output amounts for token swaps via Jupiter aggregator. (3) Meteora swap quotes - get expected output amounts for Meteora dynamic bonding curve pools.
  )
 */
export function subscribeCommonQueries(callback, queryId) {
    return subscribe(`commonQueries/${queryId}`, {
        onData: (data) => {
            callback(data);
        },
        onError: (error) => {
            console.error(`Error subscribing to CommonQueries at path '${`commonQueries/${queryId}`}': ${formatError(error)}`);
        }
    });
}
/**
 * Get many CommonQueries items from collection commonQueries
 
  Read Operation Details: Anyone can use these queries: (1) Balance queries - check SOL, USDC, or any SPL token balance for any wallet address. (2) Jupiter swap quotes - get expected output amounts for token swaps via Jupiter aggregator. (3) Meteora swap quotes - get expected output amounts for Meteora dynamic bonding curve pools.
  
 */
export async function getManyCommonQueries(filter = "") {
    try {
        const results = await get("commonQueries", { prompt: filter });
        return Array.isArray(results) ? results : [];
    }
    catch (error) {
        console.error(`Error getting CommonQueries collection at path 'commonQueries': ${formatError(error)}`);
        return [];
    }
}
/**
 * Subscribe to changes in CommonQueries collection at commonQueries
 
  Read Operation Details: Anyone can use these queries: (1) Balance queries - check SOL, USDC, or any SPL token balance for any wallet address. (2) Jupiter swap quotes - get expected output amounts for token swaps via Jupiter aggregator. (3) Meteora swap quotes - get expected output amounts for Meteora dynamic bonding curve pools.
  
 */
export function subscribeManyCommonQueries(callback, filter = "") {
    return subscribe("commonQueries", {
        prompt: filter,
        onData: (data) => {
            callback(Array.isArray(data) ? data : []);
        },
        onError: (error) => {
            console.error(`Error subscribing to CommonQueries collection at path '${"commonQueries"}': ${formatError(error)}`);
        }
    });
}
/**
 * Get all CommonQueries items from collection commonQueries
 
  Read Operation Details: Anyone can use these queries: (1) Balance queries - check SOL, USDC, or any SPL token balance for any wallet address. (2) Jupiter swap quotes - get expected output amounts for token swaps via Jupiter aggregator. (3) Meteora swap quotes - get expected output amounts for Meteora dynamic bonding curve pools.
  
 */
export async function getAllCommonQueries(filter = "") {
    try {
        const results = await get("commonQueries", { prompt: filter });
        return Array.isArray(results) ? results : [];
    }
    catch (error) {
        console.error(`Error getting CommonQueries collection at path 'commonQueries': ${formatError(error)}`);
        return [];
    }
}
/**
 * Subscribe to changes in CommonQueries collection at commonQueries
 
  Read Operation Details: Anyone can use these queries: (1) Balance queries - check SOL, USDC, or any SPL token balance for any wallet address. (2) Jupiter swap quotes - get expected output amounts for token swaps via Jupiter aggregator. (3) Meteora swap quotes - get expected output amounts for Meteora dynamic bonding curve pools.
  
 */
export function subscribeAllCommonQueries(callback, filter = "") {
    return subscribe("commonQueries", {
        prompt: filter,
        onData: (data) => {
            callback(Array.isArray(data) ? data : []);
        },
        onError: (error) => {
            console.error(`Error subscribing to CommonQueries collection at path '${"commonQueries"}': ${formatError(error)}`);
        }
    });
}
/**
 * Runs the "solBalance" query on CommonQueries.
 * Description: Get SOL balance for a wallet address in lamports (1 SOL = 1,000,000,000 lamports). Pass walletAddress as parameter.
 * Query Logic: @TokenPlugin.getBalance(@newData.walletAddress, @constants.SOL)
 */
export async function runSolBalanceQueryForCommonQueries(queryId, args) {
    try {
        const result = await runQuery(`commonQueries/${queryId}`, "solBalance", args);
        return result;
    }
    catch (error) {
        console.error(`Error running query "solBalance" on CommonQueries: ${formatError(error)}`);
        throw error;
    }
}
/**
 * Runs the "usdcBalance" query on CommonQueries.
 * Description: Get USDC balance for a wallet address in base units (1 USDC = 1,000,000 base units with 6 decimals). Pass walletAddress as parameter.
 * Query Logic: @TokenPlugin.getBalance(@newData.walletAddress, @constants.USDC)
 */
export async function runUsdcBalanceQueryForCommonQueries(queryId, args) {
    try {
        const result = await runQuery(`commonQueries/${queryId}`, "usdcBalance", args);
        return result;
    }
    catch (error) {
        console.error(`Error running query "usdcBalance" on CommonQueries: ${formatError(error)}`);
        throw error;
    }
}
/**
 * Runs the "tokenBalance" query on CommonQueries.
 * Description: Get balance for any SPL token mint for a wallet address. Pass walletAddress and tokenMint as parameters. Returns balance in the token's smallest units based on its decimals.
 * Query Logic: @TokenPlugin.getBalance(@newData.walletAddress, @newData.tokenMint)
 */
export async function runTokenBalanceQueryForCommonQueries(queryId, args) {
    try {
        const result = await runQuery(`commonQueries/${queryId}`, "tokenBalance", args);
        return result;
    }
    catch (error) {
        console.error(`Error running query "tokenBalance" on CommonQueries: ${formatError(error)}`);
        throw error;
    }
}
/**
 * Runs the "jupiterSwapQuote" query on CommonQueries.
 * Description: Get a Jupiter swap quote for exchanging tokens. Pass inputMint (token to sell, use @constants.SOL for native SOL), outputMint (token to buy), and amount (in smallest units like lamports). Returns the expected output amount.
 * Query Logic: @DeFiPlugin.getSwapQuote(@newData.inputMint, @newData.outputMint, @newData.amount)
 */
export async function runJupiterSwapQuoteQueryForCommonQueries(queryId, args) {
    try {
        const result = await runQuery(`commonQueries/${queryId}`, "jupiterSwapQuote", args);
        return result;
    }
    catch (error) {
        console.error(`Error running query "jupiterSwapQuote" on CommonQueries: ${formatError(error)}`);
        throw error;
    }
}
/**
 * Runs the "meteoraSwapQuote" query on CommonQueries.
 * Description: Get a Meteora dynamic bonding curve swap quote. Pass tokenMintAddress (the pool's base token), tokenToSwapInMintAddress (token to swap in, use @constants.SOL for native SOL), and tokenAmount (in smallest units). Returns the expected output amount.
 * Query Logic: @DeFiPlugin.getMeteoraSwapQuote(@newData.tokenMintAddress, @newData.tokenToSwapInMintAddress, @newData.tokenAmount)
 */
export async function runMeteoraSwapQuoteQueryForCommonQueries(queryId, args) {
    try {
        const result = await runQuery(`commonQueries/${queryId}`, "meteoraSwapQuote", args);
        return result;
    }
    catch (error) {
        console.error(`Error running query "meteoraSwapQuote" on CommonQueries: ${formatError(error)}`);
        throw error;
    }
}
/**
 * Build a LotteryPot operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryPot(potId, data) {
    const doc = data ? transformValues(data) : {};
    return { path: `lotteryPot/${potId}`, document: doc };
}
/**
 * Admin creates the lottery pot PDA once. The potId must match @constants.POT_ID. Creates the on-chain PDA account that holds SOL for prize payouts. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryPot(potId, data) {
    try {
        const transformedData = transformValues(data || {});
        const succeeded = await set(`lotteryPot/${potId}`, transformedData);
        return !!succeeded;
    }
    catch (error) {
        console.error(`Error setting LotteryPot: ${formatError(error)}`);
        return false;
    }
}
/**
 *
  Read Operation Details: Anyone can check the prize pot balance and status.
   (Get Single Item)
 */
export async function getLotteryPot(potId) {
    try {
        const result = await get(`lotteryPot/${potId}`);
        return result;
    }
    catch (error) {
        console.error(`Error getting LotteryPot: ${formatError(error)}`);
        return null;
    }
}
/**
 * Subscribes to changes in a single LotteryPot document. (
  Read Operation Details: Anyone can check the prize pot balance and status.
  )
 */
export function subscribeLotteryPot(callback, potId) {
    return subscribe(`lotteryPot/${potId}`, {
        onData: (data) => {
            callback(data);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryPot at path '${`lotteryPot/${potId}`}': ${formatError(error)}`);
        }
    });
}
/**
 * Get many LotteryPot items from collection lotteryPot
 
  Read Operation Details: Anyone can check the prize pot balance and status.
  
 */
export async function getManyLotteryPot(filter = "") {
    try {
        const results = await get("lotteryPot", { prompt: filter });
        return Array.isArray(results) ? results : [];
    }
    catch (error) {
        console.error(`Error getting LotteryPot collection at path 'lotteryPot': ${formatError(error)}`);
        return [];
    }
}
/**
 * Subscribe to changes in LotteryPot collection at lotteryPot
 
  Read Operation Details: Anyone can check the prize pot balance and status.
  
 */
export function subscribeManyLotteryPot(callback, filter = "") {
    return subscribe("lotteryPot", {
        prompt: filter,
        onData: (data) => {
            callback(Array.isArray(data) ? data : []);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryPot collection at path '${"lotteryPot"}': ${formatError(error)}`);
        }
    });
}
/**
 * Get all LotteryPot items from collection lotteryPot
 
  Read Operation Details: Anyone can check the prize pot balance and status.
  
 */
export async function getAllLotteryPot(filter = "") {
    try {
        const results = await get("lotteryPot", { prompt: filter });
        return Array.isArray(results) ? results : [];
    }
    catch (error) {
        console.error(`Error getting LotteryPot collection at path 'lotteryPot': ${formatError(error)}`);
        return [];
    }
}
/**
 * Subscribe to changes in LotteryPot collection at lotteryPot
 
  Read Operation Details: Anyone can check the prize pot balance and status.
  
 */
export function subscribeAllLotteryPot(callback, filter = "") {
    return subscribe("lotteryPot", {
        prompt: filter,
        onData: (data) => {
            callback(Array.isArray(data) ? data : []);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryPot collection at path '${"lotteryPot"}': ${formatError(error)}`);
        }
    });
}
/**
 * Runs the "getPotBalance" query on LotteryPot.
 * Query Logic: @TokenPlugin.getBalance(@constants.POT_ID, @constants.SOL)
 */
export async function runGetPotBalanceQueryForLotteryPot(potId) {
    try {
        const result = await runQuery(`lotteryPot/${potId}`, "getPotBalance", {});
        return result;
    }
    catch (error) {
        console.error(`Error running query "getPotBalance" on LotteryPot: ${formatError(error)}`);
        throw error;
    }
}
/**
 * Build a LotteryState operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryState(lotteryId, data) {
    const doc = transformValues(data);
    return { path: `lotteryState/${lotteryId}`, document: doc };
}
/**
 * Any authenticated user can create a new lottery round and request VRF to generate the main number (range 0 to u64 max via @constants.MAX_NUMBER). The round starts inactive until the VRF reveal sets the mainNumber and activates it. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryState(lotteryId, data) {
    try {
        const transformedData = transformValues(data);
        const succeeded = await set(`lotteryState/${lotteryId}`, transformedData);
        return !!succeeded;
    }
    catch (error) {
        console.error(`Error setting LotteryState: ${formatError(error)}`);
        return false;
    }
}
/**
 * Build a LotteryState update operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildUpdateLotteryState(lotteryId, data) {
    const doc = transformValues(data);
    return { path: `lotteryState/${lotteryId}`, document: doc };
}
/**
 * Admin only. Safety valve to manually deactivate a stuck round by setting isActive to false. Reveal hooks bypass rules via @DocumentPlugin.updateField and are unaffected by this rule. (Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the update worked.
 */
export async function updateLotteryState(lotteryId, data) {
    try {
        const transformedData = transformValues(data);
        const succeeded = await set(`lotteryState/${lotteryId}`, transformedData);
        return !!succeeded;
    }
    catch (error) {
        console.error(`Error updating LotteryState: ${formatError(error)}`);
        return false;
    }
}
/**
 *
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
   (Get Single Item)
 */
export async function getLotteryState(lotteryId) {
    try {
        const result = await get(`lotteryState/${lotteryId}`);
        return result;
    }
    catch (error) {
        console.error(`Error getting LotteryState: ${formatError(error)}`);
        return null;
    }
}
/**
 * Subscribes to changes in a single LotteryState document. (
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
  )
 */
export function subscribeLotteryState(callback, lotteryId) {
    return subscribe(`lotteryState/${lotteryId}`, {
        onData: (data) => {
            callback(data);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryState at path '${`lotteryState/${lotteryId}`}': ${formatError(error)}`);
        }
    });
}
/**
 * Get many LotteryState items from collection lotteryState
 
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
  
 */
export async function getManyLotteryState(filter = "") {
    try {
        const results = await get("lotteryState", { prompt: filter });
        return Array.isArray(results) ? results : [];
    }
    catch (error) {
        console.error(`Error getting LotteryState collection at path 'lotteryState': ${formatError(error)}`);
        return [];
    }
}
/**
 * Subscribe to changes in LotteryState collection at lotteryState
 
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
  
 */
export function subscribeManyLotteryState(callback, filter = "") {
    return subscribe("lotteryState", {
        prompt: filter,
        onData: (data) => {
            callback(Array.isArray(data) ? data : []);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryState collection at path '${"lotteryState"}': ${formatError(error)}`);
        }
    });
}
/**
 * Get all LotteryState items from collection lotteryState
 
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
  
 */
export async function getAllLotteryState(filter = "") {
    try {
        const results = await get("lotteryState", { prompt: filter });
        return Array.isArray(results) ? results : [];
    }
    catch (error) {
        console.error(`Error getting LotteryState collection at path 'lotteryState': ${formatError(error)}`);
        return [];
    }
}
/**
 * Subscribe to changes in LotteryState collection at lotteryState
 
  Read Operation Details: Anyone can view the current lottery round state including whether it is active, the main number to beat, total tickets, and last winner.
  
 */
export function subscribeAllLotteryState(callback, filter = "") {
    return subscribe("lotteryState", {
        prompt: filter,
        onData: (data) => {
            callback(Array.isArray(data) ? data : []);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryState collection at path '${"lotteryState"}': ${formatError(error)}`);
        }
    });
}
/**
 * Runs the "getMainNumber" query on LotteryState.
 * Query Logic: @OraclePlugin.getRandomNumber($lotteryId, 0, @constants.MAX_NUMBER)
 */
export async function runGetMainNumberQueryForLotteryState(lotteryId) {
    try {
        const result = await runQuery(`lotteryState/${lotteryId}`, "getMainNumber", {});
        return result;
    }
    catch (error) {
        console.error(`Error running query "getMainNumber" on LotteryState: ${formatError(error)}`);
        throw error;
    }
}
/**
 * Runs the "getVRFAddress" query on LotteryState.
 * Query Logic: @OraclePlugin.getVRFAddress($lotteryId)
 */
export async function runGetVRFAddressQueryForLotteryState(lotteryId) {
    try {
        const result = await runQuery(`lotteryState/${lotteryId}`, "getVRFAddress", {});
        return result;
    }
    catch (error) {
        console.error(`Error running query "getVRFAddress" on LotteryState: ${formatError(error)}`);
        throw error;
    }
}
/**
 * Build a LotteryStateStartReveals operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryStateStartReveals(lotteryId, revealId, data) {
    const doc = data ? transformValues(data) : {};
    return { path: `lotteryState/${lotteryId}/startReveals/${revealId}`, document: doc };
}
/**
 * Oracle VRF callback. The revealId must match lotteryId. Reads the random number for this lotteryId (0 to u64 max via @constants.MAX_NUMBER), sets it as mainNumber on the lotteryState, and activates the round. Idempotent via || true pattern. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryStateStartReveals(lotteryId, revealId, data) {
    try {
        const transformedData = transformValues(data || {});
        const succeeded = await set(`lotteryState/${lotteryId}/startReveals/${revealId}`, transformedData);
        return !!succeeded;
    }
    catch (error) {
        console.error(`Error setting LotteryStateStartReveals: ${formatError(error)}`);
        return false;
    }
}
/**
 *
  Read Operation Details: Anyone can view reveal records (fieldless).
   (Get Single Item)
 */
export async function getLotteryStateStartReveals(lotteryId, revealId) {
    try {
        const result = await get(`lotteryState/${lotteryId}/startReveals/${revealId}`);
        return result;
    }
    catch (error) {
        console.error(`Error getting LotteryStateStartReveals: ${formatError(error)}`);
        return null;
    }
}
/**
 * Subscribes to changes in a single LotteryStateStartReveals document. (
  Read Operation Details: Anyone can view reveal records (fieldless).
  )
 */
export function subscribeLotteryStateStartReveals(callback, lotteryId, revealId) {
    return subscribe(`lotteryState/${lotteryId}/startReveals/${revealId}`, {
        onData: (data) => {
            callback(data);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryStateStartReveals at path '${`lotteryState/${lotteryId}/startReveals/${revealId}`}': ${formatError(error)}`);
        }
    });
}
/**
 * Get many LotteryStateStartReveals items from collection lotteryState/${lotteryId}/startReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export async function getManyLotteryStateStartReveals(lotteryId, filter = "") {
    try {
        const results = await get(`lotteryState/${lotteryId}/startReveals`, { prompt: filter });
        return Array.isArray(results) ? results : [];
    }
    catch (error) {
        console.error(`Error getting LotteryStateStartReveals collection at path 'lotteryState/${lotteryId}/startReveals': ${formatError(error)}`);
        return [];
    }
}
/**
 * Subscribe to changes in LotteryStateStartReveals collection at lotteryState/${lotteryId}/startReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export function subscribeManyLotteryStateStartReveals(callback, lotteryId, filter = "") {
    return subscribe(`lotteryState/${lotteryId}/startReveals`, {
        prompt: filter,
        onData: (data) => {
            callback(Array.isArray(data) ? data : []);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryStateStartReveals collection at path '${`lotteryState/${lotteryId}/startReveals`}': ${formatError(error)}`);
        }
    });
}
/**
 * Get all LotteryStateStartReveals items from collection lotteryState/${lotteryId}/startReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export async function getAllLotteryStateStartReveals(lotteryId, filter = "") {
    try {
        const results = await get(`lotteryState/*/startReveals`, { prompt: filter });
        return Array.isArray(results) ? results : [];
    }
    catch (error) {
        console.error(`Error getting LotteryStateStartReveals collection at path 'lotteryState/${lotteryId}/startReveals': ${formatError(error)}`);
        return [];
    }
}
/**
 * Subscribe to changes in LotteryStateStartReveals collection at lotteryState/${lotteryId}/startReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export function subscribeAllLotteryStateStartReveals(callback, lotteryId, filter = "") {
    return subscribe(`lotteryState/*/startReveals`, {
        prompt: filter,
        onData: (data) => {
            callback(Array.isArray(data) ? data : []);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryStateStartReveals collection at path '${`lotteryState/*/startReveals`}': ${formatError(error)}`);
        }
    });
}
/**
 * Build a LotteryStateTickets operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryStateTickets(lotteryId, ticketId, data) {
    const doc = data ? transformValues(data) : {};
    return { path: `lotteryState/${lotteryId}/tickets/${ticketId}`, document: doc };
}
/**
 * Authenticated user buys a ticket for 0.01 SOL (10000000 lamports). Lottery must be active. Buyer must equal @user.address. SOL is transferred to the pot PDA via onchain hook. VRF randomness is requested for this ticket with u64 max range. The won and winNumber fields start null and are set by the reveal hook. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryStateTickets(lotteryId, ticketId, data) {
    try {
        const transformedData = transformValues(data || {});
        const succeeded = await set(`lotteryState/${lotteryId}/tickets/${ticketId}`, transformedData);
        return !!succeeded;
    }
    catch (error) {
        console.error(`Error setting LotteryStateTickets: ${formatError(error)}`);
        return false;
    }
}
/**
 *
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
   (Get Single Item)
 */
export async function getLotteryStateTickets(lotteryId, ticketId) {
    try {
        const result = await get(`lotteryState/${lotteryId}/tickets/${ticketId}`);
        return result;
    }
    catch (error) {
        console.error(`Error getting LotteryStateTickets: ${formatError(error)}`);
        return null;
    }
}
/**
 * Subscribes to changes in a single LotteryStateTickets document. (
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
  )
 */
export function subscribeLotteryStateTickets(callback, lotteryId, ticketId) {
    return subscribe(`lotteryState/${lotteryId}/tickets/${ticketId}`, {
        onData: (data) => {
            callback(data);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryStateTickets at path '${`lotteryState/${lotteryId}/tickets/${ticketId}`}': ${formatError(error)}`);
        }
    });
}
/**
 * Get many LotteryStateTickets items from collection lotteryState/${lotteryId}/tickets
 
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
  
 */
export async function getManyLotteryStateTickets(lotteryId, filter = "") {
    try {
        const results = await get(`lotteryState/${lotteryId}/tickets`, { prompt: filter });
        return Array.isArray(results) ? results : [];
    }
    catch (error) {
        console.error(`Error getting LotteryStateTickets collection at path 'lotteryState/${lotteryId}/tickets': ${formatError(error)}`);
        return [];
    }
}
/**
 * Subscribe to changes in LotteryStateTickets collection at lotteryState/${lotteryId}/tickets
 
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
  
 */
export function subscribeManyLotteryStateTickets(callback, lotteryId, filter = "") {
    return subscribe(`lotteryState/${lotteryId}/tickets`, {
        prompt: filter,
        onData: (data) => {
            callback(Array.isArray(data) ? data : []);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryStateTickets collection at path '${`lotteryState/${lotteryId}/tickets`}': ${formatError(error)}`);
        }
    });
}
/**
 * Get all LotteryStateTickets items from collection lotteryState/${lotteryId}/tickets
 
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
  
 */
export async function getAllLotteryStateTickets(lotteryId, filter = "") {
    try {
        const results = await get(`lotteryState/*/tickets`, { prompt: filter });
        return Array.isArray(results) ? results : [];
    }
    catch (error) {
        console.error(`Error getting LotteryStateTickets collection at path 'lotteryState/${lotteryId}/tickets': ${formatError(error)}`);
        return [];
    }
}
/**
 * Subscribe to changes in LotteryStateTickets collection at lotteryState/${lotteryId}/tickets
 
  Read Operation Details: Anyone can view all tickets including buyer, won status, and winning number.
  
 */
export function subscribeAllLotteryStateTickets(callback, lotteryId, filter = "") {
    return subscribe(`lotteryState/*/tickets`, {
        prompt: filter,
        onData: (data) => {
            callback(Array.isArray(data) ? data : []);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryStateTickets collection at path '${`lotteryState/*/tickets`}': ${formatError(error)}`);
        }
    });
}
/**
 * Runs the "getTicketNumber" query on LotteryStateTickets.
 * Query Logic: @OraclePlugin.getRandomNumber($ticketId, 0, @constants.MAX_NUMBER)
 */
export async function runGetTicketNumberQueryForLotteryStateTickets(lotteryId, ticketId) {
    try {
        const result = await runQuery(`lotteryState/${lotteryId}/tickets/${ticketId}`, "getTicketNumber", {});
        return result;
    }
    catch (error) {
        console.error(`Error running query "getTicketNumber" on LotteryStateTickets: ${formatError(error)}`);
        throw error;
    }
}
/**
 * Runs the "getTicketVRFAddress" query on LotteryStateTickets.
 * Query Logic: @OraclePlugin.getVRFAddress($ticketId)
 */
export async function runGetTicketVRFAddressQueryForLotteryStateTickets(lotteryId, ticketId) {
    try {
        const result = await runQuery(`lotteryState/${lotteryId}/tickets/${ticketId}`, "getTicketVRFAddress", {});
        return result;
    }
    catch (error) {
        console.error(`Error running query "getTicketVRFAddress" on LotteryStateTickets: ${formatError(error)}`);
        throw error;
    }
}
/**
 * Build a LotteryStateTicketReveals operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryStateTicketReveals(lotteryId, ticketId, data) {
    const doc = data ? transformValues(data) : {};
    return { path: `lotteryState/${lotteryId}/ticketReveals/${ticketId}`, document: doc };
}
/**
 * Oracle VRF callback. Settlement logic: Reads ticket random number (0 to u64 max via @constants.MAX_NUMBER). If number > mainNumber, ticket wins - 99% of pot balance is transferred to buyer via @TokenPlugin.transfer from PDA using integer division (1% remains in pot as seed for next round), lottery deactivates, lastWinner and lastWinNumber are set on lotteryState. If number <= mainNumber, ticket is marked as lost and pot keeps growing. Uses get() for buyer field (immutable, set on ticket create). Idempotent via || true pattern and won == null guard. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryStateTicketReveals(lotteryId, ticketId, data) {
    try {
        const transformedData = transformValues(data || {});
        const succeeded = await set(`lotteryState/${lotteryId}/ticketReveals/${ticketId}`, transformedData);
        return !!succeeded;
    }
    catch (error) {
        console.error(`Error setting LotteryStateTicketReveals: ${formatError(error)}`);
        return false;
    }
}
/**
 *
  Read Operation Details: Anyone can view reveal records (fieldless).
   (Get Single Item)
 */
export async function getLotteryStateTicketReveals(lotteryId, ticketId) {
    try {
        const result = await get(`lotteryState/${lotteryId}/ticketReveals/${ticketId}`);
        return result;
    }
    catch (error) {
        console.error(`Error getting LotteryStateTicketReveals: ${formatError(error)}`);
        return null;
    }
}
/**
 * Subscribes to changes in a single LotteryStateTicketReveals document. (
  Read Operation Details: Anyone can view reveal records (fieldless).
  )
 */
export function subscribeLotteryStateTicketReveals(callback, lotteryId, ticketId) {
    return subscribe(`lotteryState/${lotteryId}/ticketReveals/${ticketId}`, {
        onData: (data) => {
            callback(data);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryStateTicketReveals at path '${`lotteryState/${lotteryId}/ticketReveals/${ticketId}`}': ${formatError(error)}`);
        }
    });
}
/**
 * Get many LotteryStateTicketReveals items from collection lotteryState/${lotteryId}/ticketReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export async function getManyLotteryStateTicketReveals(lotteryId, filter = "") {
    try {
        const results = await get(`lotteryState/${lotteryId}/ticketReveals`, { prompt: filter });
        return Array.isArray(results) ? results : [];
    }
    catch (error) {
        console.error(`Error getting LotteryStateTicketReveals collection at path 'lotteryState/${lotteryId}/ticketReveals': ${formatError(error)}`);
        return [];
    }
}
/**
 * Subscribe to changes in LotteryStateTicketReveals collection at lotteryState/${lotteryId}/ticketReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export function subscribeManyLotteryStateTicketReveals(callback, lotteryId, filter = "") {
    return subscribe(`lotteryState/${lotteryId}/ticketReveals`, {
        prompt: filter,
        onData: (data) => {
            callback(Array.isArray(data) ? data : []);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryStateTicketReveals collection at path '${`lotteryState/${lotteryId}/ticketReveals`}': ${formatError(error)}`);
        }
    });
}
/**
 * Get all LotteryStateTicketReveals items from collection lotteryState/${lotteryId}/ticketReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export async function getAllLotteryStateTicketReveals(lotteryId, filter = "") {
    try {
        const results = await get(`lotteryState/*/ticketReveals`, { prompt: filter });
        return Array.isArray(results) ? results : [];
    }
    catch (error) {
        console.error(`Error getting LotteryStateTicketReveals collection at path 'lotteryState/${lotteryId}/ticketReveals': ${formatError(error)}`);
        return [];
    }
}
/**
 * Subscribe to changes in LotteryStateTicketReveals collection at lotteryState/${lotteryId}/ticketReveals
 
  Read Operation Details: Anyone can view reveal records (fieldless).
  
 */
export function subscribeAllLotteryStateTicketReveals(callback, lotteryId, filter = "") {
    return subscribe(`lotteryState/*/ticketReveals`, {
        prompt: filter,
        onData: (data) => {
            callback(Array.isArray(data) ? data : []);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryStateTicketReveals collection at path '${`lotteryState/*/ticketReveals`}': ${formatError(error)}`);
        }
    });
}
/**
 * Build a LotteryPotFunding operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildLotteryPotFunding(fundingId, data) {
    const doc = data ? transformValues(data) : {};
    return { path: `lotteryPotFunding/${fundingId}`, document: doc };
}
/**
 * Admin only. Transfers the specified amount of SOL (in lamports) from admin wallet to the pot PDA via onchain hook. Used to seed or top up the prize pool. (Create/Update Single Item)
 * @returns A boolean indicating whether the operation succeeded (true) or failed (false). Always check this value to confirm the write worked.
 */
export async function setLotteryPotFunding(fundingId, data) {
    try {
        const transformedData = transformValues(data || {});
        const succeeded = await set(`lotteryPotFunding/${fundingId}`, transformedData);
        return !!succeeded;
    }
    catch (error) {
        console.error(`Error setting LotteryPotFunding: ${formatError(error)}`);
        return false;
    }
}
/**
 *
  Read Operation Details: Anyone can view funding history.
   (Get Single Item)
 */
export async function getLotteryPotFunding(fundingId) {
    try {
        const result = await get(`lotteryPotFunding/${fundingId}`);
        return result;
    }
    catch (error) {
        console.error(`Error getting LotteryPotFunding: ${formatError(error)}`);
        return null;
    }
}
/**
 * Subscribes to changes in a single LotteryPotFunding document. (
  Read Operation Details: Anyone can view funding history.
  )
 */
export function subscribeLotteryPotFunding(callback, fundingId) {
    return subscribe(`lotteryPotFunding/${fundingId}`, {
        onData: (data) => {
            callback(data);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryPotFunding at path '${`lotteryPotFunding/${fundingId}`}': ${formatError(error)}`);
        }
    });
}
/**
 * Get many LotteryPotFunding items from collection lotteryPotFunding
 
  Read Operation Details: Anyone can view funding history.
  
 */
export async function getManyLotteryPotFunding(filter = "") {
    try {
        const results = await get("lotteryPotFunding", { prompt: filter });
        return Array.isArray(results) ? results : [];
    }
    catch (error) {
        console.error(`Error getting LotteryPotFunding collection at path 'lotteryPotFunding': ${formatError(error)}`);
        return [];
    }
}
/**
 * Subscribe to changes in LotteryPotFunding collection at lotteryPotFunding
 
  Read Operation Details: Anyone can view funding history.
  
 */
export function subscribeManyLotteryPotFunding(callback, filter = "") {
    return subscribe("lotteryPotFunding", {
        prompt: filter,
        onData: (data) => {
            callback(Array.isArray(data) ? data : []);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryPotFunding collection at path '${"lotteryPotFunding"}': ${formatError(error)}`);
        }
    });
}
/**
 * Get all LotteryPotFunding items from collection lotteryPotFunding
 
  Read Operation Details: Anyone can view funding history.
  
 */
export async function getAllLotteryPotFunding(filter = "") {
    try {
        const results = await get("lotteryPotFunding", { prompt: filter });
        return Array.isArray(results) ? results : [];
    }
    catch (error) {
        console.error(`Error getting LotteryPotFunding collection at path 'lotteryPotFunding': ${formatError(error)}`);
        return [];
    }
}
/**
 * Subscribe to changes in LotteryPotFunding collection at lotteryPotFunding
 
  Read Operation Details: Anyone can view funding history.
  
 */
export function subscribeAllLotteryPotFunding(callback, filter = "") {
    return subscribe("lotteryPotFunding", {
        prompt: filter,
        onData: (data) => {
            callback(Array.isArray(data) ? data : []);
        },
        onError: (error) => {
            console.error(`Error subscribing to LotteryPotFunding collection at path '${"lotteryPotFunding"}': ${formatError(error)}`);
        }
    });
}
// --- End Generated SDK ---
