// Generated by TaroBase SDK Generator: 2026-02-27T07:56:22.610Z
// Shared database client utilities and interfaces
// Edits may be overwritten by subsequent runs!
import { get, set, subscribe, setMany as tarobaseSetMany } from '@pooflabs/server';
import { getFiles, setFile } from '@pooflabs/server';
import { PublicKey } from '@solana/web3.js';
import { runQuery } from '@pooflabs/server';
// --- SDK Utilities ---
/**
 * Helper function to check if a value is a Time.Now value
 */
const isServerTimeNow = (value) => {
    return (value &&
        typeof value === "object" &&
        value.operation === "time" &&
        value.value === "now");
};
/**
 * Helper function to check if a value is an Increment operation
 */
const isIncrementOperation = (value) => {
    return (value &&
        typeof value === "object" &&
        value.operation === "increment" &&
        typeof value.value === "number");
};
/**
 * Helper function to check if a value is a TokenAmount value
 */
const isTokenAmount = (value) => {
    return value && typeof value === 'object' && value.type === 'token';
};
/**
 * Helper function to check if a value is an AddressType value
 */
const isAddressType = (value) => {
    // Check for the 'address' type property and that publicKey is an instance of PublicKey
    return value && typeof value === 'object' && value.type === 'address';
};
/**
 * Transforms special values (Time.now, Token.amount, Address.publicKey) in an object
 * to the format expected by the backend before sending the request.
 * This function is recursive and handles nested objects and arrays.
 */
const transformValues = (data) => {
    // Handle null or non-object/array types directly
    if (!data || typeof data !== 'object') {
        return data;
    }
    // Check for specific object types first using type guards
    if (isServerTimeNow(data)) {
        // Pass Time.Now object as is; backend interprets it
        return { operation: 'time', value: 'now' };
    }
    else if (isIncrementOperation(data)) {
        // Pass Increment operation as is; backend interprets it
        return { operation: 'increment', value: data.value };
    }
    else if (isTokenAmount(data)) {
        // Convert user-friendly amount to backend's integer format based on decimals
        const { name, amount } = data; // Safe access due to type guard
        if (name === 'USDC') {
            return Math.round(amount * 10 ** 6); // 6 decimals for USDC
        }
        else if (name === 'SOL' || name === 'pSOL') {
            return Math.round(amount * 10 ** 9); // 9 decimals for SOL
        }
        else {
            // Assume a default of 6 decimals for custom tokens
            return Math.round(amount * 10 ** 6);
        }
    }
    else if (isAddressType(data)) {
        // Convert AddressType to its base58 string representation for the backend
        if (typeof data.publicKey === 'string') {
            return data.publicKey;
        }
        else {
            return data.publicKey.toBase58(); // Safe access due to type guard
        }
    }
    // Handle arrays: recursively transform each item
    if (Array.isArray(data)) {
        // Use map with explicit typing for clarity
        return data.map((item) => transformValues(item));
    }
    // Handle regular objects: recursively transform each property
    // Create a new object to avoid modifying the original
    const result = {};
    for (const key in data) {
        // Use safer check for own properties
        if (Object.prototype.hasOwnProperty.call(data, key)) {
            result[key] = transformValues(data[key]);
        }
    }
    return result;
};
// --- SDK Helper Objects ---
export const Token = {
    amount: (name, amount) => ({
        type: 'token',
        name,
        amount,
    }),
    convert: (amount) => {
        // This logic mirrors the transformation in transformValues
        if (amount.name === 'USDC') {
            return Math.round(amount.amount * 10 ** 6);
        }
        else if (amount.name === 'SOL' || amount.name === 'pSOL') {
            return Math.round(amount.amount * 10 ** 9);
        }
        return Math.round(amount.amount * 10 ** 6); // Default or handle 'other'
    },
};
export const Time = {
    Now: { operation: "time", value: "now" }
};
export const Increment = {
    by: (value) => ({
        operation: "increment",
        value
    })
};
export const Address = {
    publicKey: (key) => {
        if (typeof key === 'string') {
            // Special case: 'solana' represents native SOL asset
            if (key === 'solana') {
                return {
                    type: 'address',
                    publicKey: 'solana',
                };
            }
            // Validate format: Solana addresses are 32-44 base58 characters
            if (key.length < 32 || key.length > 44) {
                throw new Error(`Invalid Solana address length: ${key.length}. Must be 32-44 characters.`);
            }
            const base58Regex = /^[1-9A-HJ-NP-Za-km-z]+$/;
            if (!base58Regex.test(key)) {
                throw new Error(`Invalid Solana address: contains invalid characters. Must be base58 encoded.`);
            }
            try {
                // Validate and create PublicKey from string
                const pkInstance = new PublicKey(key);
                return {
                    type: 'address',
                    publicKey: pkInstance,
                };
            }
            catch (e) {
                // Safer error handling
                const message = e instanceof Error ? e.message : String(e);
                console.error(`Invalid public key string provided: ${key}`, message);
                throw new Error(`Invalid public key string: ${key}. ${message}`);
            }
        }
        else if (key instanceof PublicKey) {
            return {
                type: 'address',
                publicKey: key,
            };
        }
        else {
            // Handle invalid input type
            throw new Error('Invalid input for Address.publicKey: Must be a PublicKey instance or a base58 string.');
        }
    },
};
// Re-export SDK functions for collection files
export { get, set, subscribe, getFiles, setFile, runQuery, transformValues, PublicKey };
// --- Batch Operations ---
/**
 * Execute multiple document operations in a single atomic batch.
 * Use build* functions from collection files to create operations.
 *
 * @example
 * // Atomic update across collections
 * await setMany([
 *   buildUser(userId, { name: 'John' }),
 *   buildPost(postId, { author: userId }),
 * ]);
 */
export async function setMany(operations) {
    return await tarobaseSetMany(operations);
}
// --- Error Formatting ---
/**
 * Safely format an error for logging (avoids [object Object] in logs)
 * Handles circular references, empty messages, and non-Error objects
 * Always includes the full error object for comprehensive debugging
 */
export function formatError(error) {
    if (error === null)
        return 'null';
    if (error === undefined)
        return 'undefined';
    if (typeof error === 'string')
        return error || 'Empty error string';
    // For Error instances, prepend the message for readability
    const prefix = error instanceof Error ? `${error.message?.trim() || 'No message'} | Full error: ` : '';
    try {
        // Use Object.getOwnPropertyNames to include non-enumerable properties (like Error's name, message, stack)
        const str = JSON.stringify(error, Object.getOwnPropertyNames(error), 2);
        return prefix + (str || 'Empty object');
    }
    catch {
        // Circular reference or other stringify error
        return prefix + 'Unserializable error';
    }
}
